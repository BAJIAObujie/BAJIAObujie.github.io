
<!DOCTYPE html>
<html lang="">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="芭蕉不解的博客">
    <title>UE4的热更新与HTTP（二） - 芭蕉不解的博客</title>
    <meta name="author" content="BAJIAObujie">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"BAJIAObujie","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"articleBody":"前言上一篇文章讲了UE4源码里Http的部分内容，创建一条http请求，Http模块的结构。\n这一篇内容来讲讲我在实现UE4的热更新中遇到的一些困难以及如何用UE4的Http来完成断点续传功能。\nUE4热更新的思路热更新的整体思路是这样的，文件服务器与本地都会有一个版本文件，姑且分别叫做ServerResVersion.txt和LocalResVersion.txt。也都会有一个存储资源信息的Md5文件，这个文件有多行，每一行的格式是“FileName-Md5-FileSize”，其中Md5值是用来保证下载的文件一致的。首先本地启动之后启动http请求加载服务器版本文件，加载完毕后加载本地版本文件，存储为int32 ServerResVersion 和 int32 LocalResVersion，比较版本是否有差异。随后加载本地Md5文件，存储到TMap&lt;FString, FileInfo&gt; LocalMd5，检查每一个资源名字是否在本地有对应的资源，也就是检查资源的完整性，如果资源完整且版本没有差异，那么此时就可以进入游戏了。如果有丢失文件，那么必须移除LocalMd5中对应的数据。也就是要保证LocalMd5存储的是本地存在的资源信息。\n如果资源是资源不是完整的，或者版本有更新，那么这个时候就要去加载服务器的Md5文件。知道本地资源列表LocalMd5与服务器资源列表ServerMd5之后，删除本地的无用文件，并且整理出一份下载文件列表去服务器加载新的或者丢失的资源文件。\n删除本地的无用文件，可以通过遍历LocalMd5，如果ServerMd5不存在就说明在新版本中这个资源已经被删除了。整理下载文件列表，可以通过遍历ServerMd5，如果新版本存在的而本地不存在，那么就说明这个资源要么是资源丢失，要么是新更新的资源。\n整理出一份下载文件列表之后，就当做 TArray DownloadList 吧，FString 存储的是这个资源的名字。根据自己的文件服务器host 等生成URL，生成HTTP去请求数据。\n为了确保下载的是正确内容，还可以在下载完后，对下载的数据在本地计算生成一个ComputedMd5，并且和ServerMd5的值比较一次，如果正确就说明下载的文件是正确的。\nUE4的HTTP的局限在有了热更新的思路之后，我们需要考虑如何实现具体的功能。UE4对HTTP做了一层封装，它是引用的外部库libcurl来做的底层，实现了单线程高并发，在上一篇文章中已经提过。使用这个库的例子在官网或者一些其他人分享的文章里都有很多，推荐找一找类似的文章了解一下。像后文会讲到的断点续传功能，这个库就有一个ResumeFrom的功能可以实现\ncurl_easy_setopt(handle, CURLOPT_RESUME_FROM, localFileLenth);  *// 从本地大小位置进行请求数据*\n具体可以参考这一篇文章《coco2dx c++ 断点续传实现》 https://blog.csdn.net/vpingchangxin/article/details/22309067\n虽然这个库的功能挺多，但是UE4提供的接口却不是很多。这些接口封装得很好，但是与之相对的，实现的功能就不容易拓展，尤其是在不改变源码的情况下。先来看看HTTP我们常用的函数：\n\n创建HTTP请求\n设置URL、Header、Verb\n每帧回调函数，完成回调函数\n\n对于下载小文件来说，这真的是非常方便。只需要设置URL等一些基础属性，即可下载。但是复杂的功能，比如断点续传功能，像上面的ResumeFrom的代码，源码外部是无法这么写的。总而言之就是热更新的时候，还需要对这些HTTP做一些改造才行。\n接下来将结合之前的思路来实现热更新功能。\n下载多个小文件结合热更新的思路和HTTP接口的局限，下面来实现下载多个小文件的功能。这里直接从得到文件下载列表之后接着讲，因为之前的步骤，按照思路来还是比较容易实现的。\n对 TArray DownloadList 来说，每一个FString 即 FileName即代表依次HTTP下载，对每一个HTTP下载封装为DownloadTask。所有下载任务保存在 TArray TaskArray 中。\nUpdateResourceManager 管理器启动五个下载任务，也就是提交五个HTTP请求，如果其中一个下载完成了，那么如果还有后续下载任务，继续从TaskArray中取出任务，并执行。UpdateResourceManager中还有 int32 RunningTaskNum（正在执行的HTTP请求的数量）和 int32 SuccessfulDownloadTaskNum（已经完成的请求）。\n1234567891011void UpdateResourceManager::BeginDownloadResource() &#123;\tCurHostIndex = 0;\tif (TaskArray.Num() &gt; 0) &#123;\t\tRunningTaskNum = 0;\t\tint32 ConcurrentTaskCount = FMath::Min(TaskArray.Num(), 5); //有五个任务以上时，最多同时执行五个任务\t\tfor (int32 i = 0; i &lt; ConcurrentTaskCount; i++) &#123;\t\t\tDownloadTask&amp; Task = TaskArray[i];\t\t\tTryDownloadTask();\t\t&#125;\t&#125;&#125;\n\n1234567891011121314151617181920212223242526272829void UpdateResourceManager::TryDownloadTask() &#123;\tDownloadTask*  NextDownloadTask = nullptr;\tfor (int32 i = NextDownloadTaskIndex; i &lt; TaskArray.Num() || CurHostIndex &lt; hosts.Num(); i++) &#123;\t\tif (i == TaskArray.Num()) &#123;\t\t\ti = 0;\t\t\tCurHostIndex++;\t\t\tif (CurHostIndex == hosts.Num()) &#123;\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, all hosts try&quot;), CurHostIndex - 1);\t\t\t\tbreak;\t\t\t&#125;\t\t\telse &#123;\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, CurHostIndex%d start&quot;), CurHostIndex - 1, CurHostIndex);\t\t\t&#125;\t\t&#125;\t\tif (TaskArray[i].bFinished == false &amp;&amp; TaskArray[i].IsRunning == false) &#123;\t\t\tNextDownloadTask = &amp;TaskArray[i];\t\t\tNextDownloadTaskIndex = i + 1;\t\t\tbreak;\t\t&#125;\t&#125;\tif (NextDownloadTask == nullptr) &#123;\t\t//执行TryDownload说明还有任务下载，却取不到任务说明已经尝试了hosts.Num()次下载，可能是由与网络原因失败了。\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;network doesn&apos;t work, still have DownloadTask to do.&quot;));\t\treturn;\t&#125;\tRunningTaskNum++;\tNextDownloadTask-&gt;SendHttpRequest();&#125;\n\n1234567891011121314151617181920void UpdateResourceManager::FinishOneTask(FString&amp; FileName) &#123;\tRunningTaskNum--;\tUE_LOG(LogTemp, Warning, TEXT(&quot;RunningTaskNum=%d, SuccessfulDownloadTaskNum=%d&quot;), RunningTaskNum, SuccessfulDownloadTaskNum);\t//一个下载任务完成 通知界面更新进度\tUpdateDownloadProgress();\t//完成下载任务，去下载PAk文件\tif (RunningTaskNum == 0 &amp;&amp; SuccessfulDownloadTaskNum == TaskArray.Num()) &#123;\t\tCurrentUpdateState = EUpdateState_UpdateResourceFinished;\t\tUpdateStateChange();\t&#125;\telse if (RunningTaskNum + SuccessfulDownloadTaskNum == TaskArray.Num()) &#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;waiting left DownloadTask to finish&quot;)); //应该要出现四次！\t\treturn;\t&#125;\telse &#123;\t\t//还有任务没有下载完成。\t\tTryDownloadTask();\t&#125;&#125;\n\n每次完成一个下载任务，那么检查，是否当前还有正在进行的下载任务，如果为0，且成功下载的个数等于TaskArray.Num()， 说明下载已经完成。如果剩余的下载任务与已经完成的任务的和等于TaskArray.Num()，说明不需要再去尝试下载了。\nDownloadTask定义如下：\n12345678910111213141516171819class DownloadTask &#123;private:\tUpdateResourceManager* Parent;\tFString FileName; //下载文件名字\tFString SavePath;   //下载完成后存放的位置\tint32 ServerResVersion; //组装URL\tFString Md5;      //组装URL\tpublic:\tDownloadTask(UpdateResourceManager* InParent, FString&amp; InFileName, FString&amp; InSavePath, int32 InServerResVersion, FileInfo&amp; InFileInfo)\t\t: Parent(InParent), FileName(InFileName), SavePath(InSavePath), ServerResVersion(InServerResVersion), Md5(InFileInfo.Md5), FileSize(InFileInfo.Size), bFinished(false), IsRunning(false)&#123;\t\t&#125;;\t//FString FileName; //下载文件名字\tint32 FileSize;\tbool bFinished;\tbool IsRunning;\tvoid SendHttpRequest();&#125;;\n\n其中 bFinished 为这个任务是否完成，IsRunning表明这个任务是否正在运行。TaskArray是由 UpdateResourceManager 持有的，每个DownloadTask 也会有这个热更新管理器的指针 Parent。 SendHttpRequest 如下\n1234567891011121314void DownloadTask::SendHttpRequest() &#123;\tFString URL = Parent-&gt;GetResURL(FileName, Md5);\tTSharedRef&lt;IHttpRequest&gt; HttpRequest = FHttpModule::Get().CreateRequest();\tHttpRequest-&gt;SetURL(URL);\tHttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));\tHttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) &#123;\t\t// 完成回调\t&#125;);\tHttpRequest-&gt;OnRequestProgress().BindLambda([&amp;](FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) &#123;\t    // 处理过程回调\t&#125;);\tUE_LOG(LogTemp, Warning, TEXT(&quot;DownloadTask  fileURL is (%s)&quot;), *URL);\tHttpRequest-&gt;ProcessRequest();&#125;\n\n其中完成回调：\n1234567891011121314151617181920212223242526272829303132333435363738HttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) &#123;\t\tif (bSucceeded &amp;&amp; HttpResponse.IsValid() &amp;&amp; HttpResponse-&gt;GetContentLength() &gt; 0) &#123;\t\t\tif (IFileManager::Get().FileExists(*SavePath)) &#123;\t\t\t\tIFileManager::Get().Delete(*SavePath);\t\t\t&#125;\t\t\tTArray&lt;uint8&gt; BinaryFileContent = HttpResponse-&gt;GetContent();\t\t\tFFileHelper::SaveArrayToFile(BinaryFileContent, *SavePath);\t\t\t//MD5算法\t\t\t//FString ComputedMd5 = Util::ComputeMd5();\t\t\tuint8 Digest[16];\t\t\tFMD5 FileHasher;\t\t\tFileHasher.Update(BinaryFileContent.GetData(), BinaryFileContent.Num());\t\t\tFileHasher.Final(Digest);\t\t\tFString ComputedMd5;\t\t\tfor (int32 i = 0; i &lt; 16; i++) &#123;\t\t\t\tComputedMd5 += FString::Printf(TEXT(&quot;%02x&quot;), Digest[i]);\t\t\t&#125;\t\t\t//End\t\t\tif (ComputedMd5.Equals(Md5, ESearchCase::IgnoreCase)) &#123;\t\t\t\tParent-&gt;ResourceHasUpdate.Add(FileName);\t\t\t\tParent-&gt;AppendMd5File(FileName, Md5, FileSize);\t\t\t\tParent-&gt;AppendHasUpdateFile(FileName);\t\t\t\tbFinished = true;\t\t\t\tParent-&gt;SuccessfulDownloadTaskNum++;\t\t\t\tParent-&gt;FinishOneTask(FileName);\t\t\t\treturn;\t\t\t&#125;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&apos;t be here!! Download finish but md5 doesnt match&quot;));\t\t\tParent-&gt;FinishOneTask(FileName);\t\t&#125;\t\telse &#123;\t\t\tFString URL = Parent-&gt;GetResURL(FileName, Md5);\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;DownloadTask fail... ... fileURL is (%s)&quot;), *URL);\t\t\tParent-&gt;FinishOneTask(FileName);\t\t&#125;\t&#125;);\n\n如果请求失败则通知Parent 完成了一个任务，即使他失败了。\n如果成功，则将这个文件保存到SavePath的位置，同时计算这个文件的Md5值，是否与ServerMd5值相同。如果相同那么可以确定这是一个完成的任务，把bFinished标记为成功，通知Parent。\n以上是UpdateResourceManager 和 DownloadTask 的主要代码。libcurl内部实现是可以同时执行多个HTTP请求的，但是这样每个请求的速度就会相对的下降，如果执行完一个请求再执行下一个那也太慢了。因此我们让同时执行五个HTTP请求，每一个请求执行完毕后都会执行 FinishOneTask 验证是否需要继续申请任务执行。只有还有任务待执行，那么才会执行 TryDownload 的方法。\n为什么还要设置一个 CurHostIndex 呢？在手机平台的时候，经常会有网络波动的情况。假设有可能任务20失败了，这个时候后续的任务都完成了，那么就说明还有任务需要执行，还会执行到 TryDownload 的方法。这个时候，NextTaskIndex 已经执行到末尾，让它重新归0，重新遍历，开始判断，是否这个下载任务没有完成且没有正在执行，如果是那么它就是下一个下载任务。请求失败的原因也有可能是文件服务器的不稳定，因此会部署多个文件服务器，当第一次遍历存在失败任务的时候，下一轮遍历，就去尝试第二个文件服务器的地址。\n上面我们讲了下载多个小文件的处理办法，基本上也是对UE4提供的HTTP接口做了一点封装：\n\n每一个请求封装成一个DownloadTask，记录下载状态。\n同时执行多个下载任务，保证速度。\n有几个host地址，那么就最多执行多少次遍历TaskArray，避免一些网络波动的情况。\n\n如果是Unity打包的话，这套打包机制简直为了它量身定制的，因为每个资源都是一个个独立的Bundle，那么只需要直接去下载就好了，下载失败，即使丢失数据，每一个Bundle的下载量也不大，只需要重新下载即可。但是UE4的话，热更新的文件列表里往往有一个pak的补丁包文件。这个补丁包集合了许多资源往往文件大小比较大。对手机平台来说，网络波动是很正常的事情，如果不小心网络中断，或者其他突发情况导致HTTP请求失败，那么这就意味着之前下载的数据全部消失。为了拯救它，我们需要在UE4的HTTP的基础上实现断点续传功能。\n下载单个大文件（断点续传）正如我们之前所说，虽然libcurl库提供了ResumeFrom功能做，支持断点续传，但是我们在不改变源码的情况下是无法使用的。因此我们需要自己实现一套断点续传。\n断点续传意味着，如果断开了连接，那么下次下载的时候是能够恢复进度继续执行的。思路是在HTTP下载数据的过程中就要把数据给保存在本地。那么来看看UE4提供的两个回调，每帧调用的回调只能知道下载进度，并不知道实际下载的内容。HTTP完成的回调，是可以取得HttpResponse的，但是比如网络突然中断的情况下，这个时候UE4的HTTP会被标记为完成，并且执行FinishedRequest，这个函数有两个分支，成功的话，就正常执行回调函数等等。失败的话会把HttpResonse设置为NULL，然后再执行回调函数。也就是说HTTP完成的回调有两种状态，成功的话能取到数据，失败的话是取不到已经下载的数据，也就无法把已经下载的数据给缓存下来。\nvoid OnRequestComplete(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded){}\n这么一看这种传输方式果然还是适合小文件。因为即使小文件失败了，那么直接重新下载就好了，如果失败了，那也就损失一点点流量。根本无所谓。但是如果是100、200M的文件，下载到最后突然一卡，尤其是手机平台更容易发生网络波动的情况，导致HTTP意外失败，这个时候如果必须全盘重新下载是非常糟心的体验。\n实现断点续传的方法是用HTTP的Range头来实现断点续传，把一个大文件拆分成很多个下载任务来下载，每个HTTP只下载文件的一部分。下载完成的时候，把这些零散的文件给拼接起来。重新组成一个完整的文件。既然要把文件分成多个HTTP分段下载，那么我们需要知道这个文件具体的大小，假设一个下载任务只有10M，只有知道文件的大小才知道能分多少个下载任务。\n分段下载的示例如下，如果下载范围是 0-499，那么总共是下载500个字节的数据，下一个下载范围就应该是500-999。\n12FString Range = TEXT(&quot;bytes=500-999&quot;)HttpRequest-&gt;SetHeader(TEXT(&quot;Range&quot;), Range);\n\n（更多的HTTP Header参考：https://kb.cnblogs.com/page/92320/）\n其中下载大文件，对于UE4来说主要是下载pak文件，类定义如下\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//下载pak文件class DownloadPakFileTask &#123;public:\tDownloadPakFileTask(UpdateResourceManager* InParent, FString&amp; InFileName, FString&amp; InSavePath, int32 FileSize, FString&amp; InMd5)\t\t: Parent(InParent), FileName(InFileName), SavePath(InSavePath), PakFileSize(FileSize), PakMd5(InMd5), bFinished(false), NextTaskIndex(0), SuccessfulPartialTaskCount(0), RunningHttpCount(0)\t&#123;\t\tint32 TwentyMB = 20 * 1024 * 1024;\t\tint32 TaskCount = FMath::CeilToInt(FileSize * 1.0f / TwentyMB);\t\tfor (int32 index = 0; index &lt; TaskCount; index++) &#123;\t\t\tFString From = FString::FromInt(index * TwentyMB);\t\t\tFString To = FString::FromInt((index + 1) * TwentyMB - 1); //如果文件大小是 1500KB，那么第二个PartialTask是1024-2047.超出了文件的范围，不过从PC下载测试来看是没问题的。\t\t\tFString Range = FString::Format(TEXT(&quot;bytes=&#123;0&#125;-&#123;1&#125;&quot;), &#123; From, To &#125;);\t\t\tFString Suffix = FString::Format(TEXT(&quot;temp&#123;0&#125;&quot;), &#123; index &#125;);\t\t\tFString CleanFileName = FPaths::GetCleanFilename(FileName); //去掉Paks/\t\t\tFString TaskSavePath = FString::Format(TEXT(&quot;&#123;0&#125;/HotUpdateTemp/&#123;1&#125;&#123;2&#125;&quot;), &#123; FPaths::ProjectPersistentDownloadDir(),  CleanFileName, Suffix &#125;); //  patchPak.paktemp1   patchPak.paktemp2\t\t\t//PartialTask Task = PartialTask(this, FileName, false, Range, TaskSavePath);\t\t\tPartialTasks.Add(new PartialTask(this, FileName, false, Range, TaskSavePath));\t\t&#125;\t&#125;\t//上次http没有完全下载，记录下上次下载的内容。没有完全下载可能是因为http失败，也有可能是正常的发生意外。\tDownloadPakFileTask(UpdateResourceManager* InParent, TArray&lt;FString&gt;&amp; DownloadRecords,FString&amp; PakFileName, FString&amp; InSavePath, int32 FileSize, FString&amp; InMd5)\t\t: Parent(InParent),FileName(PakFileName), SavePath(InSavePath), PakFileSize(FileSize), PakMd5(InMd5), bFinished(false), NextTaskIndex(-1), SuccessfulPartialTaskCount(0), RunningHttpCount(0)\t&#123;\t\tint32 TwentyMB = 20 * 1024 * 1024;\t\tfor (int32 i = 4; i &lt; DownloadRecords.Num(); i++) &#123;\t\t\tFString&amp; Line = DownloadRecords[i];\t\t\tint32 index = i - 4; //第5行开始是版本. index是下载任务对应的索引、后缀\t\t\tTArray&lt;FString&gt; temp1;// FileName,bSucceed,URL,,,,,\t\t\tLine.ParseIntoArray(temp1, TEXT(&quot;,&quot;), true);\t\t\tFString&amp; FileName = temp1[0];\t\t\tFString&amp; Range = temp1[2];\t\t\tFString&amp; SavePath = temp1[3];\t\t\tif (temp1[1] == TEXT(&quot;1&quot;)) &#123; // 1表示下载完成，0表示尚未下载或者上次下载失败。\t\t\t\tPartialTasks.Add(new PartialTask(this, FileName, true, Range, SavePath));\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask%d has finished&quot;), index);\t\t\t\tSuccessfulPartialTaskCount++;\t\t\t&#125;\t\t\telse &#123;\t\t\t\tPartialTasks.Add(new PartialTask(this, FileName, false, Range, SavePath));\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask%d need download&quot;), index);\t\t\t&#125;\t\t&#125;\t\tfor (int32 i = 0; i &lt; PartialTasks.Num(); i++) &#123;\t\t\tPartialTask* Task = PartialTasks[i];\t\t\tif (Task-&gt;bFinished == false) &#123;\t\t\t\tNextTaskIndex = i;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;\tUpdateResourceManager* Parent;\tFString FileName;\tFString SavePath;\tint32 PakFileSize;\tFString PakMd5;\tbool bFinished;\tTArray&lt;PartialTask*&gt; PartialTasks;\tint32 NextTaskIndex; //下一个执行任务的索引;\tint32 SuccessfulPartialTaskCount;\tvoid SendHttps();\tvoid FinishOnePartialTask();\tint32 RunningHttpCount; //当前有多少个HTTP正在请求数据&#125;;\n\nDownloadPakFileTask 的 FinishOnePartialTask如下\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void DownloadPakFileTask::FinishOnePartialTask() &#123;\tRunningHttpCount--;\tUE_LOG(LogTemp, Warning, TEXT(&quot;RunningHttpCount:%d, SuccessfulPartialTaskCount:%d&quot;), RunningHttpCount, SuccessfulPartialTaskCount); //应该要出现四次！\tParent-&gt;UpdateDownloadProgress();\tif (RunningHttpCount == 0 &amp;&amp; SuccessfulPartialTaskCount == PartialTasks.Num()) &#123;\t\t//完成全部下载任务开始拼接\t\tFArchive* FileWriter = IFileManager::Get().CreateFileWriter(*SavePath);\t\tfor (int32 index = 0; index &lt; PartialTasks.Num(); index++) &#123;\t\t\tif (Parent-&gt;bTest) &#123;\t\t\t\tFString log = FString::Format(TEXT(&quot;LoadFile:&#123;0&#125;&quot;), &#123; PartialTasks[index]-&gt;SavePath &#125;);\t\t\t\tGEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;LoadFile:%s&quot;), *(PartialTasks[index]-&gt;SavePath)); \t\t\t&#125;\t\t\tTArray&lt;uint8&gt; Buffer;\t\t\tFFileHelper::LoadFileToArray(Buffer, *(PartialTasks[index]-&gt;SavePath));\t\t\tFileWriter-&gt;Serialize(Buffer.GetData(), Buffer.Num());\t\t&#125;\t\tFileWriter-&gt;Close();\t\tdelete FileWriter;\t\t//拼接完成 删除临时文件\t\tIFileManager::Get().DeleteDirectory(*Parent-&gt;BreakPointDirectory, false, true);\t\tIFileManager::Get().Delete(*Parent-&gt;BreakPointInfoFilePath);\t\tIFileManager::Get().Delete(*Parent-&gt;BreakPointVersionFilePath);\t\t//Pak Md5\t\tTArray&lt;uint8&gt; PakContent;\t\tFFileHelper::LoadFileToArray(PakContent, *SavePath);\t\tuint8 Digest[16];\t\tFMD5 FileHasher;\t\tFileHasher.Update(PakContent.GetData(), PakContent.Num());\t\tFileHasher.Final(Digest);\t\tFString ComputedPakMd5;\t\tfor (int32 i = 0; i &lt; 16; i++) &#123;\t\t\tComputedPakMd5 += FString::Printf(TEXT(&quot;%02x&quot;), Digest[i]); // 02表明如果结果为一位，则高位补充0， x 表明是结果16进制输出，\t\t&#125;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;ComputedPakMd5:%s&quot;), *ComputedPakMd5);\t\tif (!PakMd5.Equals(ComputedPakMd5, ESearchCase::IgnoreCase)) &#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&apos;t be here!! DownloadPak finish but md5 doesnt match. exit&quot;));\t\t\treturn;\t\t&#125;\t\tbFinished = true;\t\tParent-&gt;ResourceHasUpdate.Add(FileName);\t\tParent-&gt;AppendMd5File(FileName, PakMd5, PakFileSize);\t\tParent-&gt;AppendHasUpdateFile(FileName);\t\tif (Parent-&gt;bTest) &#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;pakfile finish:%s&quot;), *FileName);\t\t\tFString log = FString::Format(TEXT(&quot;pakfile finish:&#123;0&#125;&quot;), &#123; FileName &#125;);\t\t\tGEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);\t\t&#125;\t\tParent-&gt;CurrentUpdateState = EUpdateState_UpdatePakFile;\t\tParent-&gt;UpdateStateChange();\t&#125;\telse if ((RunningHttpCount + SuccessfulPartialTaskCount) == PartialTasks.Num()) &#123;\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;waiting left PartialTask to finish&quot;)); //应该要出现四次！\t\treturn;\t&#125;\telse &#123;\t\t//还有http任务需要执行\t\tSendHttps();\t&#125;&#125;\n\nDownloadPakFileTask 的 SendHttps 如下\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void DownloadPakFileTask::SendHttps() &#123;\t//找到下一个HTTP任务\tPartialTask* NextTask = nullptr;\tfor (int32 i = NextTaskIndex; i &lt; PartialTasks.Num() || Parent-&gt;CurHostIndex &lt; Parent-&gt;hosts.Num(); i++) &#123;\t\t//遍历一次PartialTasks为一轮，在当前这一轮中，如果已经遍历结束，那么转到下一轮，查询是否有需要下载的任务（可能有因为网络波动而终止的HTTP，这些任务在下一轮中执行）\t\tif (i == PartialTasks.Num()) &#123;\t\t\ti = 0;\t\t\tParent-&gt;CurHostIndex++;\t\t\tif (Parent-&gt;CurHostIndex == Parent-&gt;hosts.Num()) &#123;\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;try all host, but still have PartialTask to finish&quot;));\t\t\t\tbreak;\t\t\t&#125;\t\t\telse &#123;\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, CurHostIndex%d start&quot;), Parent-&gt;CurHostIndex - 1, Parent-&gt;CurHostIndex);\t\t\t&#125;\t\t&#125;\t\tif (PartialTasks[i]-&gt;bFinished == false &amp;&amp; PartialTasks[i]-&gt;IsRunning == false) &#123;\t\t\tNextTask = PartialTasks[i];\t\t\tNextTaskIndex = i + 1;\t\t\tbreak;\t\t&#125;\t&#125;\t//在进行了多轮的执行任务，如果取不到下一个HTTP任务，也可能是由于网络问题，虽然仍然有任务没有完成，但是遍历次数已经达到，不在遍历去取任务。保存断点信息。\tif (NextTask == nullptr) &#123;\t\tbool bAllTaskFinished = true;\t\tfor (int32 i = 0; i &lt; PartialTasks.Num(); i++) &#123;\t\t\tif (PartialTasks[i]-&gt;bFinished == false) &#123;\t\t\t\tbAllTaskFinished = false;\t\t\t&#125;\t\t&#125;\t\tif (bAllTaskFinished == false) &#123;\t\t\tif (RunningHttpCount != 0) &#123; // 网络中断。最后一条请求失败后保存信息，避免重复保存\t\t\t\treturn;\t\t\t&#125;\t\t\tif (Parent-&gt;bTest) &#123;\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;network doesn&apos;t work, still have partialtask to do. save info to local&quot;));\t\t\t\tFString log = TEXT(&quot;network doesn&apos;t work, still have partialtask to do. save info to local&quot;);\t\t\t\tGEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);\t\t\t&#125;\t\t\t//网络原因没有全部下载，记录本次下载的版本、所有的任务及完成情况，下次启动如果还是在更新这个版本，那么断点续传，取得这个保存的txt用来恢复信息并且继续下载\t\t\tTArray&lt;FString&gt; VersionTxt;\t\t\tFString VersionInfo = FString::FromInt(Parent-&gt;ServerResVersion); //保存正在热更新中的服务器版本，下次更新如果还是这个版本就可以断点续传，如果是新版本就要把这些记录文件删掉\t\t\tVersionTxt.Add(VersionInfo);\t\t\tVersionTxt.Add(FileName);\t\t\tFFileHelper::SaveStringArrayToFile(VersionTxt, *Parent-&gt;BreakPointVersionFilePath);\t\t\tTArray&lt;FString&gt; Info;\t\t\tInfo.Add(FileName);\t\t\tInfo.Add(SavePath);\t\t\tInfo.Add(FString::FromInt(PakFileSize));\t\t\tInfo.Add(PakMd5);\t\t\tfor (int32 i = 0; i &lt; PartialTasks.Num(); i++) &#123;\t\t\t\tPartialTask* Task = PartialTasks[i];\t\t\t\tFString bFinished = Task-&gt;bFinished ? TEXT(&quot;1&quot;) : TEXT(&quot;0&quot;);\t\t\t\tFString TaskInfo = FString::Format(TEXT(&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;,&#123;3&#125;&quot;), &#123; Task-&gt;FileName, bFinished, Task-&gt;Range, Task-&gt;SavePath &#125;);\t\t\t\tInfo.Add(TaskInfo);\t\t\t&#125;\t\t\tFFileHelper::SaveStringArrayToFile(Info, *Parent-&gt;BreakPointInfoFilePath);\t\t&#125;\t\telse &#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&apos;t be here&quot;));\t\t&#125;\t\treturn;\t&#125;\tRunningHttpCount++;\tNextTask-&gt;SendPartialTaskHttp();&#125;\n\n对于下载大文件DownloadPakFileTask来说，有两种生成对象的方式，第一种传入FileName 和 FileSize等，根据FileSize计算出有多少个PartialTask。另一种是根据 TArray 的方式来生成对象，这种方式是为了断点续传设计的。如果上次下载失败了，那么就记录DownloadPakFileTask 和 PartialTask 的信息到一个txt文本中，如果下次下载检测到存在这个txt文件，就读取内容保存到TArray中，根据这些信息就可以恢复进度继续下载。\n每一个被拆分的出来的小任务PartialTask定义如下：\n123456789101112class PartialTask &#123;public:\tPartialTask(class DownloadPakFileTask* InParent, FString&amp; InFileName, bool InbFinished, FString&amp; InRange, FString&amp; InSavePath)\t\t: PakFileTask(InParent), FileName(InFileName), bFinished(InbFinished), Range(InRange), SavePath(InSavePath), IsRunning(false) &#123;&#125;\tDownloadPakFileTask* PakFileTask;\tFString FileName;\tbool bFinished; //是否下载任务已经完成\tFString Range;\tFString SavePath;\tbool IsRunning;//是否任务正在下载\tvoid SendPartialTaskHttp();&#125;;\n\n1234567891011121314151617181920212223242526272829303132void PartialTask::SendPartialTaskHttp() &#123;\tFString URL = PakFileTask-&gt;Parent-&gt;GetResURL(FileName, PakFileTask-&gt;PakMd5);\tTSharedRef&lt;IHttpRequest&gt; HttpRequest = FHttpModule::Get().CreateRequest();\tHttpRequest-&gt;SetURL(URL);\tHttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));\tHttpRequest-&gt;SetHeader(TEXT(&quot;Range&quot;), Range);\tHttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) &#123;\t\tIsRunning = false;\t\tif (!bSucceeded) &#123;\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask(%s) fail&quot;), *SavePath);\t\t\tPakFileTask-&gt;FinishOnePartialTask(); //bFinished = false\t\t&#125;\t\telse &#123;\t\t\tif (PakFileTask-&gt;Parent-&gt;bTest) &#123;\t\t\t\tFString log = FString::Format(TEXT(&quot;PartialTask(&#123;0&#125;) succeed&quot;), &#123; SavePath &#125;);\t\t\t\tGEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask(%s) succeed&quot;), *SavePath);\t\t\t&#125;\t\t\t\t\t\tFFileHelper::SaveArrayToFile(HttpResponse-&gt;GetContent(), *SavePath);\t\t\tbFinished = true;\t\t\tPakFileTask-&gt;SuccessfulPartialTaskCount++;\t\t\tPakFileTask-&gt;FinishOnePartialTask();\t\t&#125;\t&#125;);\t//HttpRequest-&gt;OnRequestProgress().BindLambda([&amp;](FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) &#123;\t//\tUE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask:%d, PakFileTask-&gt;PakFileSize:%d&quot;), PakFileTask, PakFileTask-&gt;PakFileSize);\t//&#125;);\t//UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask::SendPartialTaskHttp()&quot;));\tIsRunning = true;\tHttpRequest-&gt;ProcessRequest();&#125;\n\n总体的步骤和之前下载多个小文件是类似的，CurHostIndex可以用来进行多轮、变换host地址下载。同时进行多个PartialTask。当下载任务全部完成之后，就开始拼接每一个文件，组合成最后的pak文件。\n补充对要保存一个新文件，或者对已存在文件增添新内容：\n12345678910void AMyActor::WriteFile(FString&amp; SavePath, TArray&lt;uint8&gt;&amp; Content) &#123;\tif (!FPaths::FileExists(SavePath)) &#123;\t\tFFileHelper::SaveArrayToFile(Content, *SavePath);\t&#125;\telse &#123;\t\tFArchive* FileWriter = IFileManager::Get().CreateFileWriter(*SavePath, EFileWrite::FILEWRITE_Append);\t\tFileWriter-&gt;Serialize(Content.GetData(), Content.Num());\t\tFileWriter-&gt;Close();\t&#125;&#125;\n\n","dateCreated":"2019-06-02T00:00:00+08:00","dateModified":"2019-06-05T20:43:32+08:00","datePublished":"2019-06-02T00:00:00+08:00","description":"","headline":"UE4的热更新与HTTP（二）","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"},"publisher":{"@type":"Organization","name":"BAJIAObujie","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"url":"http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"}</script>
    <meta name="description" content="前言上一篇文章讲了UE4源码里Http的部分内容，创建一条http请求，Http模块的结构。 这一篇内容来讲讲我在实现UE4的热更新中遇到的一些困难以及如何用UE4的Http来完成断点续传功能。 UE4热更新的思路热更新的整体思路是这样的，文件服务器与本地都会有一个版本文件，姑且分别叫做ServerResVersion.txt和LocalResVersion.txt。也都会有一个存储资源信息的Md">
<meta property="og:type" content="blog">
<meta property="og:title" content="UE4的热更新与HTTP（二）">
<meta property="og:url" content="http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/index.html">
<meta property="og:site_name" content="芭蕉不解的博客">
<meta property="og:description" content="前言上一篇文章讲了UE4源码里Http的部分内容，创建一条http请求，Http模块的结构。 这一篇内容来讲讲我在实现UE4的热更新中遇到的一些困难以及如何用UE4的Http来完成断点续传功能。 UE4热更新的思路热更新的整体思路是这样的，文件服务器与本地都会有一个版本文件，姑且分别叫做ServerResVersion.txt和LocalResVersion.txt。也都会有一个存储资源信息的Md">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-05T12:43:32.888Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UE4的热更新与HTTP（二）">
<meta name="twitter:description" content="前言上一篇文章讲了UE4源码里Http的部分内容，创建一条http请求，Http模块的结构。 这一篇内容来讲讲我在实现UE4的热更新中遇到的一些困难以及如何用UE4的Http来完成断点续传功能。 UE4热更新的思路热更新的整体思路是这样的，文件服务器与本地都会有一个版本文件，姑且分别叫做ServerResVersion.txt和LocalResVersion.txt。也都会有一个存储资源信息的Md">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            芭蕉不解的博客
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Öffne den Link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Kategorien"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Kategorien</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archiv"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archiv</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Suche"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Suche</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="Über"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Über</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://plus.google.com/" target="_blank" rel="noopener" title="Google Plus">
                    
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/profile/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/mailto"
                            title="E-Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">E-Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            UE4的热更新与HTTP（二）
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-06-02T00:00:00+08:00">
	
		    02 Jun 2019
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章讲了UE4源码里Http的部分内容，创建一条http请求，Http模块的结构。</p>
<p>这一篇内容来讲讲我在实现UE4的热更新中遇到的一些困难以及如何用UE4的Http来完成断点续传功能。</p>
<h2 id="UE4热更新的思路"><a href="#UE4热更新的思路" class="headerlink" title="UE4热更新的思路"></a>UE4热更新的思路</h2><p>热更新的整体思路是这样的，文件服务器与本地都会有一个版本文件，姑且分别叫做ServerResVersion.txt和LocalResVersion.txt。也都会有一个存储资源信息的Md5文件，这个文件有多行，每一行的格式是“FileName-Md5-FileSize”，其中Md5值是用来保证下载的文件一致的。首先本地启动之后启动http请求加载服务器版本文件，加载完毕后加载本地版本文件，存储为int32 ServerResVersion 和 int32 LocalResVersion，比较版本是否有差异。随后加载本地Md5文件，存储到TMap&lt;FString, FileInfo&gt; LocalMd5，检查每一个资源名字是否在本地有对应的资源，也就是检查资源的完整性，如果资源完整且版本没有差异，那么此时就可以进入游戏了。如果有丢失文件，那么必须移除LocalMd5中对应的数据。也就是要保证LocalMd5存储的是本地存在的资源信息。</p>
<p>如果资源是资源不是完整的，或者版本有更新，那么这个时候就要去加载服务器的Md5文件。知道本地资源列表LocalMd5与服务器资源列表ServerMd5之后，删除本地的无用文件，并且整理出一份下载文件列表去服务器加载新的或者丢失的资源文件。</p>
<p>删除本地的无用文件，可以通过遍历LocalMd5，如果ServerMd5不存在就说明在新版本中这个资源已经被删除了。整理下载文件列表，可以通过遍历ServerMd5，如果新版本存在的而本地不存在，那么就说明这个资源要么是资源丢失，要么是新更新的资源。</p>
<p>整理出一份下载文件列表之后，就当做 TArray<fstring> DownloadList 吧，FString 存储的是这个资源的名字。根据自己的文件服务器host 等生成URL，生成HTTP去请求数据。</fstring></p>
<p>为了确保下载的是正确内容，还可以在下载完后，对下载的数据在本地计算生成一个ComputedMd5，并且和ServerMd5的值比较一次，如果正确就说明下载的文件是正确的。</p>
<h2 id="UE4的HTTP的局限"><a href="#UE4的HTTP的局限" class="headerlink" title="UE4的HTTP的局限"></a>UE4的HTTP的局限</h2><p>在有了热更新的思路之后，我们需要考虑如何实现具体的功能。UE4对HTTP做了一层封装，它是引用的外部库libcurl来做的底层，实现了单线程高并发，在上一篇文章中已经提过。使用这个库的例子在官网或者一些其他人分享的文章里都有很多，推荐找一找类似的文章了解一下。像后文会讲到的断点续传功能，这个库就有一个ResumeFrom的功能可以实现</p>
<p><code>curl_easy_setopt(handle, CURLOPT_RESUME_FROM, localFileLenth);  *// 从本地大小位置进行请求数据*</code></p>
<p>具体可以参考这一篇文章《coco2dx c++ 断点续传实现》 <a href="https://blog.csdn.net/vpingchangxin/article/details/22309067" target="_blank" rel="noopener">https://blog.csdn.net/vpingchangxin/article/details/22309067</a></p>
<p>虽然这个库的功能挺多，但是UE4提供的接口却不是很多。这些接口封装得很好，但是与之相对的，实现的功能就不容易拓展，尤其是在不改变源码的情况下。先来看看HTTP我们常用的函数：</p>
<ol>
<li>创建HTTP请求</li>
<li>设置URL、Header、Verb</li>
<li>每帧回调函数，完成回调函数</li>
</ol>
<p>对于下载小文件来说，这真的是非常方便。只需要设置URL等一些基础属性，即可下载。但是复杂的功能，比如断点续传功能，像上面的ResumeFrom的代码，源码外部是无法这么写的。总而言之就是热更新的时候，还需要对这些HTTP做一些改造才行。</p>
<p>接下来将结合之前的思路来实现热更新功能。</p>
<h2 id="下载多个小文件"><a href="#下载多个小文件" class="headerlink" title="下载多个小文件"></a>下载多个小文件</h2><p>结合热更新的思路和HTTP接口的局限，下面来实现下载多个小文件的功能。这里直接从得到文件下载列表之后接着讲，因为之前的步骤，按照思路来还是比较容易实现的。</p>
<p>对 TArray<fstring> DownloadList 来说，每一个FString 即 FileName即代表依次HTTP下载，对每一个HTTP下载封装为DownloadTask。所有下载任务保存在 TArray<downloadtask> TaskArray 中。</downloadtask></fstring></p>
<p>UpdateResourceManager 管理器启动五个下载任务，也就是提交五个HTTP请求，如果其中一个下载完成了，那么如果还有后续下载任务，继续从TaskArray中取出任务，并执行。UpdateResourceManager中还有 int32 RunningTaskNum（正在执行的HTTP请求的数量）和 int32 SuccessfulDownloadTaskNum（已经完成的请求）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void UpdateResourceManager::BeginDownloadResource() &#123;</span><br><span class="line">	CurHostIndex = 0;</span><br><span class="line">	if (TaskArray.Num() &gt; 0) &#123;</span><br><span class="line">		RunningTaskNum = 0;</span><br><span class="line">		int32 ConcurrentTaskCount = FMath::Min(TaskArray.Num(), 5); //有五个任务以上时，最多同时执行五个任务</span><br><span class="line">		for (int32 i = 0; i &lt; ConcurrentTaskCount; i++) &#123;</span><br><span class="line">			DownloadTask&amp; Task = TaskArray[i];</span><br><span class="line">			TryDownloadTask();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void UpdateResourceManager::TryDownloadTask() &#123;</span><br><span class="line">	DownloadTask*  NextDownloadTask = nullptr;</span><br><span class="line">	for (int32 i = NextDownloadTaskIndex; i &lt; TaskArray.Num() || CurHostIndex &lt; hosts.Num(); i++) &#123;</span><br><span class="line">		if (i == TaskArray.Num()) &#123;</span><br><span class="line">			i = 0;</span><br><span class="line">			CurHostIndex++;</span><br><span class="line">			if (CurHostIndex == hosts.Num()) &#123;</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, all hosts try&quot;), CurHostIndex - 1);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, CurHostIndex%d start&quot;), CurHostIndex - 1, CurHostIndex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (TaskArray[i].bFinished == false &amp;&amp; TaskArray[i].IsRunning == false) &#123;</span><br><span class="line">			NextDownloadTask = &amp;TaskArray[i];</span><br><span class="line">			NextDownloadTaskIndex = i + 1;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (NextDownloadTask == nullptr) &#123;</span><br><span class="line">		//执行TryDownload说明还有任务下载，却取不到任务说明已经尝试了hosts.Num()次下载，可能是由与网络原因失败了。</span><br><span class="line">		UE_LOG(LogTemp, Warning, TEXT(&quot;network doesn&apos;t work, still have DownloadTask to do.&quot;));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	RunningTaskNum++;</span><br><span class="line">	NextDownloadTask-&gt;SendHttpRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void UpdateResourceManager::FinishOneTask(FString&amp; FileName) &#123;</span><br><span class="line">	RunningTaskNum--;</span><br><span class="line">	UE_LOG(LogTemp, Warning, TEXT(&quot;RunningTaskNum=%d, SuccessfulDownloadTaskNum=%d&quot;), RunningTaskNum, SuccessfulDownloadTaskNum);</span><br><span class="line">	//一个下载任务完成 通知界面更新进度</span><br><span class="line">	UpdateDownloadProgress();</span><br><span class="line"></span><br><span class="line">	//完成下载任务，去下载PAk文件</span><br><span class="line">	if (RunningTaskNum == 0 &amp;&amp; SuccessfulDownloadTaskNum == TaskArray.Num()) &#123;</span><br><span class="line">		CurrentUpdateState = EUpdateState_UpdateResourceFinished;</span><br><span class="line">		UpdateStateChange();</span><br><span class="line">	&#125;</span><br><span class="line">	else if (RunningTaskNum + SuccessfulDownloadTaskNum == TaskArray.Num()) &#123;</span><br><span class="line">		UE_LOG(LogTemp, Warning, TEXT(&quot;waiting left DownloadTask to finish&quot;)); //应该要出现四次！</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		//还有任务没有下载完成。</span><br><span class="line">		TryDownloadTask();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次完成一个下载任务，那么检查，是否当前还有正在进行的下载任务，如果为0，且成功下载的个数等于TaskArray.Num()， 说明下载已经完成。如果剩余的下载任务与已经完成的任务的和等于TaskArray.Num()，说明不需要再去尝试下载了。</p>
<p>DownloadTask定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DownloadTask &#123;</span><br><span class="line">private:</span><br><span class="line">	UpdateResourceManager* Parent;</span><br><span class="line">	FString FileName; //下载文件名字</span><br><span class="line">	FString SavePath;   //下载完成后存放的位置</span><br><span class="line">	int32 ServerResVersion; //组装URL</span><br><span class="line">	FString Md5;      //组装URL</span><br><span class="line">	</span><br><span class="line">public:</span><br><span class="line">	DownloadTask(UpdateResourceManager* InParent, FString&amp; InFileName, FString&amp; InSavePath, int32 InServerResVersion, FileInfo&amp; InFileInfo)</span><br><span class="line">		: Parent(InParent), FileName(InFileName), SavePath(InSavePath), ServerResVersion(InServerResVersion), Md5(InFileInfo.Md5), FileSize(InFileInfo.Size), bFinished(false), IsRunning(false)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;;</span><br><span class="line">	//FString FileName; //下载文件名字</span><br><span class="line">	int32 FileSize;</span><br><span class="line">	bool bFinished;</span><br><span class="line">	bool IsRunning;</span><br><span class="line">	void SendHttpRequest();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 bFinished 为这个任务是否完成，IsRunning表明这个任务是否正在运行。TaskArray是由 UpdateResourceManager 持有的，每个DownloadTask 也会有这个热更新管理器的指针 Parent。 SendHttpRequest 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void DownloadTask::SendHttpRequest() &#123;</span><br><span class="line">	FString URL = Parent-&gt;GetResURL(FileName, Md5);</span><br><span class="line">	TSharedRef&lt;IHttpRequest&gt; HttpRequest = FHttpModule::Get().CreateRequest();</span><br><span class="line">	HttpRequest-&gt;SetURL(URL);</span><br><span class="line">	HttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));</span><br><span class="line">	HttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) &#123;</span><br><span class="line">		// 完成回调</span><br><span class="line">	&#125;);</span><br><span class="line">	HttpRequest-&gt;OnRequestProgress().BindLambda([&amp;](FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) &#123;</span><br><span class="line">	    // 处理过程回调</span><br><span class="line">	&#125;);</span><br><span class="line">	UE_LOG(LogTemp, Warning, TEXT(&quot;DownloadTask  fileURL is (%s)&quot;), *URL);</span><br><span class="line">	HttpRequest-&gt;ProcessRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中完成回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) &#123;</span><br><span class="line">		if (bSucceeded &amp;&amp; HttpResponse.IsValid() &amp;&amp; HttpResponse-&gt;GetContentLength() &gt; 0) &#123;</span><br><span class="line">			if (IFileManager::Get().FileExists(*SavePath)) &#123;</span><br><span class="line">				IFileManager::Get().Delete(*SavePath);</span><br><span class="line">			&#125;</span><br><span class="line">			TArray&lt;uint8&gt; BinaryFileContent = HttpResponse-&gt;GetContent();</span><br><span class="line">			FFileHelper::SaveArrayToFile(BinaryFileContent, *SavePath);</span><br><span class="line"></span><br><span class="line">			//MD5算法</span><br><span class="line">			//FString ComputedMd5 = Util::ComputeMd5();</span><br><span class="line">			uint8 Digest[16];</span><br><span class="line">			FMD5 FileHasher;</span><br><span class="line">			FileHasher.Update(BinaryFileContent.GetData(), BinaryFileContent.Num());</span><br><span class="line">			FileHasher.Final(Digest);</span><br><span class="line">			FString ComputedMd5;</span><br><span class="line">			for (int32 i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">				ComputedMd5 += FString::Printf(TEXT(&quot;%02x&quot;), Digest[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			//End</span><br><span class="line"></span><br><span class="line">			if (ComputedMd5.Equals(Md5, ESearchCase::IgnoreCase)) &#123;</span><br><span class="line">				Parent-&gt;ResourceHasUpdate.Add(FileName);</span><br><span class="line">				Parent-&gt;AppendMd5File(FileName, Md5, FileSize);</span><br><span class="line">				Parent-&gt;AppendHasUpdateFile(FileName);</span><br><span class="line">				bFinished = true;</span><br><span class="line">				Parent-&gt;SuccessfulDownloadTaskNum++;</span><br><span class="line">				Parent-&gt;FinishOneTask(FileName);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			UE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&apos;t be here!! Download finish but md5 doesnt match&quot;));</span><br><span class="line">			Parent-&gt;FinishOneTask(FileName);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			FString URL = Parent-&gt;GetResURL(FileName, Md5);</span><br><span class="line">			UE_LOG(LogTemp, Warning, TEXT(&quot;DownloadTask fail... ... fileURL is (%s)&quot;), *URL);</span><br><span class="line">			Parent-&gt;FinishOneTask(FileName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<p>如果请求失败则通知Parent 完成了一个任务，即使他失败了。</p>
<p>如果成功，则将这个文件保存到SavePath的位置，同时计算这个文件的Md5值，是否与ServerMd5值相同。如果相同那么可以确定这是一个完成的任务，把bFinished标记为成功，通知Parent。</p>
<p>以上是UpdateResourceManager 和 DownloadTask 的主要代码。libcurl内部实现是可以同时执行多个HTTP请求的，但是这样每个请求的速度就会相对的下降，如果执行完一个请求再执行下一个那也太慢了。因此我们让同时执行五个HTTP请求，每一个请求执行完毕后都会执行 FinishOneTask 验证是否需要继续申请任务执行。<strong>只有还有任务待执行，那么才会执行 TryDownload 的方法。</strong></p>
<p>为什么还要设置一个 CurHostIndex 呢？在手机平台的时候，经常会有网络波动的情况。假设有可能任务20失败了，这个时候后续的任务都完成了，那么就说明还有任务需要执行，还会执行到 TryDownload 的方法。这个时候，NextTaskIndex 已经执行到末尾，让它重新归0，重新遍历，开始判断，是否这个下载任务没有完成且没有正在执行，如果是那么它就是下一个下载任务。请求失败的原因也有可能是文件服务器的不稳定，因此会部署多个文件服务器，当第一次遍历存在失败任务的时候，下一轮遍历，就去尝试第二个文件服务器的地址。</p>
<p>上面我们讲了下载多个小文件的处理办法，基本上也是对UE4提供的HTTP接口做了一点封装：</p>
<ul>
<li>每一个请求封装成一个DownloadTask，记录下载状态。</li>
<li>同时执行多个下载任务，保证速度。</li>
<li>有几个host地址，那么就最多执行多少次遍历TaskArray，避免一些网络波动的情况。</li>
</ul>
<p>如果是Unity打包的话，这套打包机制简直为了它量身定制的，因为每个资源都是一个个独立的Bundle，那么只需要直接去下载就好了，下载失败，即使丢失数据，每一个Bundle的下载量也不大，只需要重新下载即可。但是UE4的话，热更新的文件列表里往往有一个pak的补丁包文件。这个补丁包集合了许多资源往往文件大小比较大。对手机平台来说，网络波动是很正常的事情，如果不小心网络中断，或者其他突发情况导致HTTP请求失败，那么这就意味着之前下载的数据全部消失。为了拯救它，我们需要在UE4的HTTP的基础上实现断点续传功能。</p>
<h2 id="下载单个大文件（断点续传）"><a href="#下载单个大文件（断点续传）" class="headerlink" title="下载单个大文件（断点续传）"></a>下载单个大文件（断点续传）</h2><p>正如我们之前所说，虽然libcurl库提供了ResumeFrom功能做，支持断点续传，但是我们在不改变源码的情况下是无法使用的。因此我们需要自己实现一套断点续传。</p>
<p>断点续传意味着，如果断开了连接，那么下次下载的时候是能够恢复进度继续执行的。思路是在HTTP下载数据的过程中就要把数据给保存在本地。那么来看看UE4提供的两个回调，每帧调用的回调只能知道下载进度，并不知道实际下载的内容。HTTP完成的回调，是可以取得HttpResponse的，但是比如网络突然中断的情况下，这个时候UE4的HTTP会被标记为完成，并且执行FinishedRequest，这个函数有两个分支，成功的话，就正常执行回调函数等等。失败的话会把HttpResonse设置为NULL，然后再执行回调函数。也就是说HTTP完成的回调有两种状态，成功的话能取到数据，失败的话是取不到已经下载的数据，也就无法把已经下载的数据给缓存下来。</p>
<p><code>void OnRequestComplete(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded){}</code></p>
<p>这么一看这种传输方式果然还是适合小文件。因为即使小文件失败了，那么直接重新下载就好了，如果失败了，那也就损失一点点流量。根本无所谓。但是如果是100、200M的文件，下载到最后突然一卡，尤其是手机平台更容易发生网络波动的情况，导致HTTP意外失败，这个时候如果必须全盘重新下载是非常糟心的体验。</p>
<p>实现断点续传的方法是用HTTP的Range头来实现断点续传，把一个大文件拆分成很多个下载任务来下载，每个HTTP只下载文件的一部分。下载完成的时候，把这些零散的文件给拼接起来。重新组成一个完整的文件。既然要把文件分成多个HTTP分段下载，那么我们需要知道这个文件具体的大小，假设一个下载任务只有10M，只有知道文件的大小才知道能分多少个下载任务。</p>
<p>分段下载的示例如下，如果下载范围是 0-499，那么总共是下载500个字节的数据，下一个下载范围就应该是500-999。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FString Range = TEXT(&quot;bytes=500-999&quot;)</span><br><span class="line">HttpRequest-&gt;SetHeader(TEXT(&quot;Range&quot;), Range);</span><br></pre></td></tr></table></figure>

<p>（更多的HTTP Header参考：<a href="https://kb.cnblogs.com/page/92320/）" target="_blank" rel="noopener">https://kb.cnblogs.com/page/92320/）</a></p>
<p>其中下载大文件，对于UE4来说主要是下载pak文件，类定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//下载pak文件</span><br><span class="line">class DownloadPakFileTask &#123;</span><br><span class="line">public:</span><br><span class="line">	DownloadPakFileTask(UpdateResourceManager* InParent, FString&amp; InFileName, FString&amp; InSavePath, int32 FileSize, FString&amp; InMd5)</span><br><span class="line">		: Parent(InParent), FileName(InFileName), SavePath(InSavePath), PakFileSize(FileSize), PakMd5(InMd5), bFinished(false), NextTaskIndex(0), SuccessfulPartialTaskCount(0), RunningHttpCount(0)</span><br><span class="line">	&#123;</span><br><span class="line">		int32 TwentyMB = 20 * 1024 * 1024;</span><br><span class="line">		int32 TaskCount = FMath::CeilToInt(FileSize * 1.0f / TwentyMB);</span><br><span class="line">		for (int32 index = 0; index &lt; TaskCount; index++) &#123;</span><br><span class="line">			FString From = FString::FromInt(index * TwentyMB);</span><br><span class="line">			FString To = FString::FromInt((index + 1) * TwentyMB - 1); //如果文件大小是 1500KB，那么第二个PartialTask是1024-2047.超出了文件的范围，不过从PC下载测试来看是没问题的。</span><br><span class="line">			FString Range = FString::Format(TEXT(&quot;bytes=&#123;0&#125;-&#123;1&#125;&quot;), &#123; From, To &#125;);</span><br><span class="line">			FString Suffix = FString::Format(TEXT(&quot;temp&#123;0&#125;&quot;), &#123; index &#125;);</span><br><span class="line">			FString CleanFileName = FPaths::GetCleanFilename(FileName); //去掉Paks/</span><br><span class="line">			FString TaskSavePath = FString::Format(TEXT(&quot;&#123;0&#125;/HotUpdateTemp/&#123;1&#125;&#123;2&#125;&quot;), &#123; FPaths::ProjectPersistentDownloadDir(),  CleanFileName, Suffix &#125;); //  patchPak.paktemp1   patchPak.paktemp2</span><br><span class="line">			//PartialTask Task = PartialTask(this, FileName, false, Range, TaskSavePath);</span><br><span class="line">			PartialTasks.Add(new PartialTask(this, FileName, false, Range, TaskSavePath));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//上次http没有完全下载，记录下上次下载的内容。没有完全下载可能是因为http失败，也有可能是正常的发生意外。</span><br><span class="line">	DownloadPakFileTask(UpdateResourceManager* InParent, TArray&lt;FString&gt;&amp; DownloadRecords,FString&amp; PakFileName, FString&amp; InSavePath, int32 FileSize, FString&amp; InMd5)</span><br><span class="line">		: Parent(InParent),FileName(PakFileName), SavePath(InSavePath), PakFileSize(FileSize), PakMd5(InMd5), bFinished(false), NextTaskIndex(-1), SuccessfulPartialTaskCount(0), RunningHttpCount(0)</span><br><span class="line">	&#123;</span><br><span class="line">		int32 TwentyMB = 20 * 1024 * 1024;</span><br><span class="line">		for (int32 i = 4; i &lt; DownloadRecords.Num(); i++) &#123;</span><br><span class="line">			FString&amp; Line = DownloadRecords[i];</span><br><span class="line">			int32 index = i - 4; //第5行开始是版本. index是下载任务对应的索引、后缀</span><br><span class="line">			TArray&lt;FString&gt; temp1;// FileName,bSucceed,URL,,,,,</span><br><span class="line">			Line.ParseIntoArray(temp1, TEXT(&quot;,&quot;), true);</span><br><span class="line">			FString&amp; FileName = temp1[0];</span><br><span class="line">			FString&amp; Range = temp1[2];</span><br><span class="line">			FString&amp; SavePath = temp1[3];</span><br><span class="line">			if (temp1[1] == TEXT(&quot;1&quot;)) &#123; // 1表示下载完成，0表示尚未下载或者上次下载失败。</span><br><span class="line">				PartialTasks.Add(new PartialTask(this, FileName, true, Range, SavePath));</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask%d has finished&quot;), index);</span><br><span class="line">				SuccessfulPartialTaskCount++;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				PartialTasks.Add(new PartialTask(this, FileName, false, Range, SavePath));</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask%d need download&quot;), index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int32 i = 0; i &lt; PartialTasks.Num(); i++) &#123;</span><br><span class="line">			PartialTask* Task = PartialTasks[i];</span><br><span class="line">			if (Task-&gt;bFinished == false) &#123;</span><br><span class="line">				NextTaskIndex = i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	UpdateResourceManager* Parent;</span><br><span class="line">	FString FileName;</span><br><span class="line">	FString SavePath;</span><br><span class="line">	int32 PakFileSize;</span><br><span class="line">	FString PakMd5;</span><br><span class="line">	bool bFinished;</span><br><span class="line"></span><br><span class="line">	TArray&lt;PartialTask*&gt; PartialTasks;</span><br><span class="line">	int32 NextTaskIndex; //下一个执行任务的索引;</span><br><span class="line">	int32 SuccessfulPartialTaskCount;</span><br><span class="line">	void SendHttps();</span><br><span class="line">	void FinishOnePartialTask();</span><br><span class="line"></span><br><span class="line">	int32 RunningHttpCount; //当前有多少个HTTP正在请求数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>DownloadPakFileTask 的 FinishOnePartialTask如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void DownloadPakFileTask::FinishOnePartialTask() &#123;</span><br><span class="line">	RunningHttpCount--;</span><br><span class="line">	UE_LOG(LogTemp, Warning, TEXT(&quot;RunningHttpCount:%d, SuccessfulPartialTaskCount:%d&quot;), RunningHttpCount, SuccessfulPartialTaskCount); //应该要出现四次！</span><br><span class="line">	Parent-&gt;UpdateDownloadProgress();</span><br><span class="line">	if (RunningHttpCount == 0 &amp;&amp; SuccessfulPartialTaskCount == PartialTasks.Num()) &#123;</span><br><span class="line">		//完成全部下载任务开始拼接</span><br><span class="line">		FArchive* FileWriter = IFileManager::Get().CreateFileWriter(*SavePath);</span><br><span class="line">		for (int32 index = 0; index &lt; PartialTasks.Num(); index++) &#123;</span><br><span class="line">			if (Parent-&gt;bTest) &#123;</span><br><span class="line">				FString log = FString::Format(TEXT(&quot;LoadFile:&#123;0&#125;&quot;), &#123; PartialTasks[index]-&gt;SavePath &#125;);</span><br><span class="line">				GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;LoadFile:%s&quot;), *(PartialTasks[index]-&gt;SavePath)); </span><br><span class="line">			&#125;</span><br><span class="line">			TArray&lt;uint8&gt; Buffer;</span><br><span class="line">			FFileHelper::LoadFileToArray(Buffer, *(PartialTasks[index]-&gt;SavePath));</span><br><span class="line">			FileWriter-&gt;Serialize(Buffer.GetData(), Buffer.Num());</span><br><span class="line">		&#125;</span><br><span class="line">		FileWriter-&gt;Close();</span><br><span class="line">		delete FileWriter;</span><br><span class="line">		//拼接完成 删除临时文件</span><br><span class="line">		IFileManager::Get().DeleteDirectory(*Parent-&gt;BreakPointDirectory, false, true);</span><br><span class="line">		IFileManager::Get().Delete(*Parent-&gt;BreakPointInfoFilePath);</span><br><span class="line">		IFileManager::Get().Delete(*Parent-&gt;BreakPointVersionFilePath);</span><br><span class="line"></span><br><span class="line">		//Pak Md5</span><br><span class="line">		TArray&lt;uint8&gt; PakContent;</span><br><span class="line">		FFileHelper::LoadFileToArray(PakContent, *SavePath);</span><br><span class="line">		uint8 Digest[16];</span><br><span class="line">		FMD5 FileHasher;</span><br><span class="line">		FileHasher.Update(PakContent.GetData(), PakContent.Num());</span><br><span class="line">		FileHasher.Final(Digest);</span><br><span class="line">		FString ComputedPakMd5;</span><br><span class="line">		for (int32 i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">			ComputedPakMd5 += FString::Printf(TEXT(&quot;%02x&quot;), Digest[i]); // 02表明如果结果为一位，则高位补充0， x 表明是结果16进制输出，</span><br><span class="line">		&#125;</span><br><span class="line">		UE_LOG(LogTemp, Warning, TEXT(&quot;ComputedPakMd5:%s&quot;), *ComputedPakMd5);</span><br><span class="line">		if (!PakMd5.Equals(ComputedPakMd5, ESearchCase::IgnoreCase)) &#123;</span><br><span class="line">			UE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&apos;t be here!! DownloadPak finish but md5 doesnt match. exit&quot;));</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		bFinished = true;</span><br><span class="line">		Parent-&gt;ResourceHasUpdate.Add(FileName);</span><br><span class="line">		Parent-&gt;AppendMd5File(FileName, PakMd5, PakFileSize);</span><br><span class="line">		Parent-&gt;AppendHasUpdateFile(FileName);</span><br><span class="line"></span><br><span class="line">		if (Parent-&gt;bTest) &#123;</span><br><span class="line">			UE_LOG(LogTemp, Warning, TEXT(&quot;pakfile finish:%s&quot;), *FileName);</span><br><span class="line">			FString log = FString::Format(TEXT(&quot;pakfile finish:&#123;0&#125;&quot;), &#123; FileName &#125;);</span><br><span class="line">			GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Parent-&gt;CurrentUpdateState = EUpdateState_UpdatePakFile;</span><br><span class="line">		Parent-&gt;UpdateStateChange();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	else if ((RunningHttpCount + SuccessfulPartialTaskCount) == PartialTasks.Num()) &#123;</span><br><span class="line">		UE_LOG(LogTemp, Warning, TEXT(&quot;waiting left PartialTask to finish&quot;)); //应该要出现四次！</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		//还有http任务需要执行</span><br><span class="line">		SendHttps();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DownloadPakFileTask 的 SendHttps 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void DownloadPakFileTask::SendHttps() &#123;</span><br><span class="line">	//找到下一个HTTP任务</span><br><span class="line">	PartialTask* NextTask = nullptr;</span><br><span class="line">	for (int32 i = NextTaskIndex; i &lt; PartialTasks.Num() || Parent-&gt;CurHostIndex &lt; Parent-&gt;hosts.Num(); i++) &#123;</span><br><span class="line">		//遍历一次PartialTasks为一轮，在当前这一轮中，如果已经遍历结束，那么转到下一轮，查询是否有需要下载的任务（可能有因为网络波动而终止的HTTP，这些任务在下一轮中执行）</span><br><span class="line">		if (i == PartialTasks.Num()) &#123;</span><br><span class="line">			i = 0;</span><br><span class="line">			Parent-&gt;CurHostIndex++;</span><br><span class="line">			if (Parent-&gt;CurHostIndex == Parent-&gt;hosts.Num()) &#123;</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;try all host, but still have PartialTask to finish&quot;));</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, CurHostIndex%d start&quot;), Parent-&gt;CurHostIndex - 1, Parent-&gt;CurHostIndex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (PartialTasks[i]-&gt;bFinished == false &amp;&amp; PartialTasks[i]-&gt;IsRunning == false) &#123;</span><br><span class="line">			NextTask = PartialTasks[i];</span><br><span class="line">			NextTaskIndex = i + 1;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//在进行了多轮的执行任务，如果取不到下一个HTTP任务，也可能是由于网络问题，虽然仍然有任务没有完成，但是遍历次数已经达到，不在遍历去取任务。保存断点信息。</span><br><span class="line">	if (NextTask == nullptr) &#123;</span><br><span class="line">		bool bAllTaskFinished = true;</span><br><span class="line">		for (int32 i = 0; i &lt; PartialTasks.Num(); i++) &#123;</span><br><span class="line">			if (PartialTasks[i]-&gt;bFinished == false) &#123;</span><br><span class="line">				bAllTaskFinished = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (bAllTaskFinished == false) &#123;</span><br><span class="line">			if (RunningHttpCount != 0) &#123; // 网络中断。最后一条请求失败后保存信息，避免重复保存</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			if (Parent-&gt;bTest) &#123;</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;network doesn&apos;t work, still have partialtask to do. save info to local&quot;));</span><br><span class="line">				FString log = TEXT(&quot;network doesn&apos;t work, still have partialtask to do. save info to local&quot;);</span><br><span class="line">				GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);</span><br><span class="line">			&#125;</span><br><span class="line">			//网络原因没有全部下载，记录本次下载的版本、所有的任务及完成情况，下次启动如果还是在更新这个版本，那么断点续传，取得这个保存的txt用来恢复信息并且继续下载</span><br><span class="line">			TArray&lt;FString&gt; VersionTxt;</span><br><span class="line">			FString VersionInfo = FString::FromInt(Parent-&gt;ServerResVersion); //保存正在热更新中的服务器版本，下次更新如果还是这个版本就可以断点续传，如果是新版本就要把这些记录文件删掉</span><br><span class="line">			VersionTxt.Add(VersionInfo);</span><br><span class="line">			VersionTxt.Add(FileName);</span><br><span class="line">			FFileHelper::SaveStringArrayToFile(VersionTxt, *Parent-&gt;BreakPointVersionFilePath);</span><br><span class="line">			TArray&lt;FString&gt; Info;</span><br><span class="line">			Info.Add(FileName);</span><br><span class="line">			Info.Add(SavePath);</span><br><span class="line">			Info.Add(FString::FromInt(PakFileSize));</span><br><span class="line">			Info.Add(PakMd5);</span><br><span class="line">			for (int32 i = 0; i &lt; PartialTasks.Num(); i++) &#123;</span><br><span class="line">				PartialTask* Task = PartialTasks[i];</span><br><span class="line">				FString bFinished = Task-&gt;bFinished ? TEXT(&quot;1&quot;) : TEXT(&quot;0&quot;);</span><br><span class="line">				FString TaskInfo = FString::Format(TEXT(&quot;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;,&#123;3&#125;&quot;), &#123; Task-&gt;FileName, bFinished, Task-&gt;Range, Task-&gt;SavePath &#125;);</span><br><span class="line">				Info.Add(TaskInfo);</span><br><span class="line">			&#125;</span><br><span class="line">			FFileHelper::SaveStringArrayToFile(Info, *Parent-&gt;BreakPointInfoFilePath);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			UE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&apos;t be here&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	RunningHttpCount++;</span><br><span class="line">	NextTask-&gt;SendPartialTaskHttp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于下载大文件DownloadPakFileTask来说，有两种生成对象的方式，第一种传入FileName 和 FileSize等，根据FileSize计算出有多少个PartialTask。另一种是根据 TArray<fstring> 的方式来生成对象，这种方式是为了断点续传设计的。如果上次下载失败了，那么就记录DownloadPakFileTask 和 PartialTask 的信息到一个txt文本中，如果下次下载检测到存在这个txt文件，就读取内容保存到TArray<fstring>中，根据这些信息就可以恢复进度继续下载。</fstring></fstring></p>
<p>每一个被拆分的出来的小任务PartialTask定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class PartialTask &#123;</span><br><span class="line">public:</span><br><span class="line">	PartialTask(class DownloadPakFileTask* InParent, FString&amp; InFileName, bool InbFinished, FString&amp; InRange, FString&amp; InSavePath)</span><br><span class="line">		: PakFileTask(InParent), FileName(InFileName), bFinished(InbFinished), Range(InRange), SavePath(InSavePath), IsRunning(false) &#123;&#125;</span><br><span class="line">	DownloadPakFileTask* PakFileTask;</span><br><span class="line">	FString FileName;</span><br><span class="line">	bool bFinished; //是否下载任务已经完成</span><br><span class="line">	FString Range;</span><br><span class="line">	FString SavePath;</span><br><span class="line">	bool IsRunning;//是否任务正在下载</span><br><span class="line">	void SendPartialTaskHttp();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void PartialTask::SendPartialTaskHttp() &#123;</span><br><span class="line">	FString URL = PakFileTask-&gt;Parent-&gt;GetResURL(FileName, PakFileTask-&gt;PakMd5);</span><br><span class="line">	TSharedRef&lt;IHttpRequest&gt; HttpRequest = FHttpModule::Get().CreateRequest();</span><br><span class="line">	HttpRequest-&gt;SetURL(URL);</span><br><span class="line">	HttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));</span><br><span class="line">	HttpRequest-&gt;SetHeader(TEXT(&quot;Range&quot;), Range);</span><br><span class="line">	HttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) &#123;</span><br><span class="line">		IsRunning = false;</span><br><span class="line">		if (!bSucceeded) &#123;</span><br><span class="line">			UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask(%s) fail&quot;), *SavePath);</span><br><span class="line">			PakFileTask-&gt;FinishOnePartialTask(); //bFinished = false</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (PakFileTask-&gt;Parent-&gt;bTest) &#123;</span><br><span class="line">				FString log = FString::Format(TEXT(&quot;PartialTask(&#123;0&#125;) succeed&quot;), &#123; SavePath &#125;);</span><br><span class="line">				GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);</span><br><span class="line">				UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask(%s) succeed&quot;), *SavePath);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			FFileHelper::SaveArrayToFile(HttpResponse-&gt;GetContent(), *SavePath);</span><br><span class="line">			bFinished = true;</span><br><span class="line">			PakFileTask-&gt;SuccessfulPartialTaskCount++;</span><br><span class="line">			PakFileTask-&gt;FinishOnePartialTask();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	//HttpRequest-&gt;OnRequestProgress().BindLambda([&amp;](FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) &#123;</span><br><span class="line">	//	UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask:%d, PakFileTask-&gt;PakFileSize:%d&quot;), PakFileTask, PakFileTask-&gt;PakFileSize);</span><br><span class="line">	//&#125;);</span><br><span class="line">	//UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask::SendPartialTaskHttp()&quot;));</span><br><span class="line">	IsRunning = true;</span><br><span class="line">	HttpRequest-&gt;ProcessRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体的步骤和之前下载多个小文件是类似的，CurHostIndex可以用来进行多轮、变换host地址下载。同时进行多个PartialTask。当下载任务全部完成之后，就开始拼接每一个文件，组合成最后的pak文件。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对要保存一个新文件，或者对已存在文件增添新内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void AMyActor::WriteFile(FString&amp; SavePath, TArray&lt;uint8&gt;&amp; Content) &#123;</span><br><span class="line">	if (!FPaths::FileExists(SavePath)) &#123;</span><br><span class="line">		FFileHelper::SaveArrayToFile(Content, *SavePath);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		FArchive* FileWriter = IFileManager::Get().CreateFileWriter(*SavePath, EFileWrite::FILEWRITE_Append);</span><br><span class="line">		FileWriter-&gt;Serialize(Content.GetData(), Content.Num());</span><br><span class="line">		FileWriter-&gt;Close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/06/02/2019-06-02-UE4的热更新与HTTP（一）/"
                    data-tooltip="UE4的热更新与HTTP（一）"
                    aria-label="FRÜHER: UE4的热更新与HTTP（一）"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/16/2019-05-16-UE4安卓相关路径/"
                    data-tooltip="UE4安卓相关路径"
                    aria-label="NÄCHSTER: UE4安卓相关路径"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 BAJIAObujie. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/06/02/2019-06-02-UE4的热更新与HTTP（一）/"
                    data-tooltip="UE4的热更新与HTTP（一）"
                    aria-label="FRÜHER: UE4的热更新与HTTP（一）"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">FRÜHER</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/05/16/2019-05-16-UE4安卓相关路径/"
                    data-tooltip="UE4安卓相关路径"
                    aria-label="NÄCHSTER: UE4安卓相关路径"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NÄCHSTER</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                    title="Teilen auf Facebook"
                    aria-label="Teilen auf Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                    title="Teilen auf Twitter"
                    aria-label="Teilen auf Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                    title="Teilen auf Google Plus"
                    aria-label="Teilen auf Google Plus"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                        aria-label="Teilen auf Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Teilen auf Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                        aria-label="Teilen auf Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Teilen auf Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/"
                        aria-label="Teilen auf Google Plus"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Teilen auf Google Plus</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">BAJIAObujie</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>

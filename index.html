<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="芭蕉不解的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="芭蕉不解的博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="芭蕉不解的博客">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>芭蕉不解的博客</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  <div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">芭蕉不解的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archiv</a>

  </li>
    </ul>
    

</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/29/2019-06-29-写在毕业一周年/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/29/2019-06-29-写在毕业一周年/" class="post-title-link" itemprop="url">写在毕业一周年</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-29T00:00:00+08:00">2019-06-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-31 11:03:28" itemprop="dateModified" datetime="2019-07-31T11:03:28+08:00">2019-07-31</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年2018年的6月28日毕业，转眼正好一年又一天了，之前一直有总结这两年生活、工作的想法，恰好今天是周六，难得有比较多的空余时间，就来记录记录这两年的事情。</p>
<h2 id="2017-06-2017-08"><a href="#2017-06-2017-08" class="headerlink" title="2017.06 - 2017.08"></a>2017.06 - 2017.08</h2><p>两年前，大概也同样是六月份吧，收到了一份游戏公司的offer，就开始了实习的生活。直到现在还记得挺清楚的是，在去公司的前一周，恰好看到一部动画叫做 “new game!”，一部萌妹子们在游戏公司做游戏的动画。当时是第一季，而我去实习那段时间，好像第二季正好完结了。一直都有做游戏和加入游戏公司的想法，这部动画当时更让我对游戏公司的生活充满好感。动画里有这么一个片段，地铁到站，主人公凉风青叶顺着简笔画般，只有轮廓的人流从地铁出来，爬上黑压压的楼梯。实习的时候从学校出发，坐公交车到10号线好像，然后乘地铁到望京东。到达望京东，出来的那一刻，感觉就是动画的场景重现一样，如果有一个动画里那个视角的摄像机，那肯定构图也是差不多的。当时的自己在公司里不忙，而且那时候好像996也还没有兴起（笑），虽然可以早些下班，但是不愿意那么早下班回去，经常可以拖到9、10点才走，大概就是被打了鸡血吧。当时自己的想法蛮多都和动画挺接近的，工作上有难点经常就想到第一季第三季里末尾的continue?这首歌。也想着未来有一天，能和八神光一样能离开。</p>
<p>那个时候正好是大三结束，大三下有一个图像处理的C++作业，还有一个Android的音乐播放器，自己比较自信有掌握好这些内容，所以想着实习也就这样吧，自己可以hold得住。自己确实在这个实习的过程没感觉到什么压力，但是并不是因为自己掌握得比较好，而是压根没什么任务需要我去完成。加入项目并不是说马上加入的，至少得把对应的技能栈刷上来，再把工程的源码给读完，这个过程就得消耗很多时间了。我想这是当时没什么任务给我的原因。猜想如果大四接着来才会加入项目吧。现在想起来当时的自己感觉编程是真的菜。实习的时候在NGUI里发现C#的一个语法“delegate”能赶紧去写一篇博客，还有一篇关于网络编程的也是。不能说大学学的内容派不上用场，而是总感觉自己还是太菜，并没有好好学习。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/1.jpg" alt="image"></p>
<p>*<center>望京东夜景</center>* </p>
<p>左边这栋楼就是当时实习的大楼，楼顶挂着阿里健康的牌子。远处两个灯火通明的弧形大楼就是望京soho。右边就是地铁站。后边就还是正在开发的大楼。每天中午吃饭的时候往窗外看能看见零零星星的工人。</p>
<h2 id="2017-09-2017-11"><a href="#2017-09-2017-11" class="headerlink" title="2017.09 - 2017.11"></a>2017.09 - 2017.11</h2><p>这段时间秋招进行时，深感自己基础薄弱，这段时间是在刷基础和笔试中度过的。不过确实夯实基础了。太菜了以至于自己不想去回顾了。</p>
<h2 id="2017-12-2018-6"><a href="#2017-12-2018-6" class="headerlink" title="2017.12 - 2018.6"></a>2017.12 - 2018.6</h2><p>工作上这段时间可以分为两个时间段 2017.12 - 2018.4 和 2018.5 - 2018.6。</p>
<p>2017.12 - 2018.4 期间加入了另外一家游戏公司，拿到了当时感觉还可以的offer。这段时间主要就做了三件事，第一是用C#从零开始写了一个软渲染器，这段期间还回顾了计算机图形学（Leader出身完美，据他所说，每一个新加入完美的程序，都要写一个软渲染器）。第二是读完了Lua程序设计这本书。第三是看了那本Unity官方出的大部头的入门书。在之前实习的时候其实并不知道自己具体要做的方向在哪里，往哪些方向学习，感觉就是一种懵懂的状态。当时的Leader应该技术还不错吧，关系也挺好的，但是并不适合指导别人。新的Leader让我感觉就很不错。只不过鸡血已经渐渐消失，上班开始会划水了，哈哈。</p>
<p>2018.5 - 2018.6期间自己算是加入项目了，花了一些时间了解了源码，开始接手一些一些成熟模块的功能，比如排行榜啦，这个功能的策划还是北邮的前辈，当时公司好些个北邮的，可以后来发生了变故，现在只剩下我和另外一个程序大佬。虽然是成熟的功能但是也有改动的需求，当时一个需求是需要在排行榜里加入一个宠物战力榜，这实在是有些折磨人。排行榜从第一名到最后一名都是取唯一个ID来排名的。比如人物战力榜上的每一个人物都是唯一的身份ID，帮派榜是根据帮派的繁荣程度来排名的，以一个帮派ID作为记录。那么宠物应该也是这样吧，只需要记录宠物ID-宠物战力即可。但是宠物ID不是唯一的，宠物是附属于人物的，也就是说必须同时知道人物ID、宠物ID才可以索引到宠物。例如角色A的人物ID是10086，总共有五只宠物，ID分别是是1-5。角色B的人物ID是1314，有三只宠物，宠物ID为1-3。这样就没办法根据宠物ID来唯一确定一只宠物。这家公司和其他公司还不太一样，其他公司分前端，后端。这家公司是负责一个模块的话，需要负责从客户端到服务器端的全部实现。那怎么动手改呢？服务端的代码都是以唯一ID来编写的通用代码，如果只是加一个 if( 宠物榜 ){ … …  }这也太Low了。哎，一言难尽，最后是改成了用一个主ID和副ID来索引，但是代码确实膨胀了一些。</p>
<p>其实更好的实现方式是宠物ID一开始就不能这么实现。把每个宠物都应该有一个明确唯一的ID，不附属于人物。这样排行榜压根不需要改动。即使是现在，宠物也没有改过来，真的是让人无语。没办法呀，明明知道是不好的设计，还得往上添砖加瓦。用程序员的话来说，就是“shi山”。</p>
<p>这段时间，除了工作上的事，在学校主要是做毕设。</p>
<p>自己很早就确定毕设想要做卡通渲染了，了解到上一届有人跟院长做的这个毕设，所以今年也跟院长申请这个题目。在边看UnityShader入门精要这本书，同时公司那边也做着软渲染器，两者还挺互补的。毕设作品还是有一些成果的吧。但是想要好的美术效果，果然还是要点一些美术技能。不然即使程序上实现了功能，美术上做不出来，结果也是一般的。</p>
<p>6月末的时候，毕业了，第一次穿上学士服。发照片给妈妈看，二姨也在，她们很开心。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/2.jpg" alt="image"></p>
<p>*<center>离校前拍的最后一张西门照片</center>* </p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/3.jpg" alt="image"></p>
<p>*<center>秋天，漫咖啡前的树</center>* </p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/4.jpg" alt="image"></p>
<p>*<center>秋天，漫咖啡前的树</center>* </p>
<p>秋天时候的树总让我想起犬夜叉17还是18集，是桔梗复活那一集中犬夜叉回忆的一个片段。在 悲運の巫女 音乐中，桔梗和村里的小孩在红叶树下玩耍。桔梗是我的女神！</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/5.jpg" alt="image"></p>
<p>*<center>冬天，树掉光了叶子</center>* </p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/6.jpg" alt="image"></p>
<p>*<center>主干道</center>* </p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/7.jpg" alt="image"></p>
<p>*<center>交叉路口</center>* </p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/8.jpg" alt="image"></p>
<p>*<center>西门与学一之间的路</center>* </p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/9.jpg" alt="image"></p>
<p>*<center>从专教的过道往外看</center>* </p>
<h2 id="2018-7-2019-1"><a href="#2018-7-2019-1" class="headerlink" title="2018.7 - 2019.1"></a>2018.7 - 2019.1</h2><p>毕业了，在公司附近租的房子。之前实习的时候从学校去望京单程得花一个小时，深深感到了通勤的痛苦。在公司附近虽然房租贵了一些，但是好在步行上班，每天花固定的时间。不用公交不用地铁意味着节省了时间，比如不用提前去车站等车浪费时间。每天节省下来的时间可以在房间里看看书，这一点让自己还是很满意的。而且这里离学校也是一路公交直达不必换乘，偶尔去学校也相当方便。</p>
<p>全职上班的前几个月里，一开始就感觉任务加重了，负责的模块多了。当时为了完成一个服务器端的功能，周日也特地去公司加班。对的，这个时候996的生活已经开始，周六已经开始上班了。也就是一段时间内吧，几乎除了睡觉就是在公司了，晚上入睡前，早上醒过来都还会想着怎么实现这个功能比较好。当时还是挺焦虑的，特别担心会重蹈FGO终章事件的覆辙，17年的秋招那段时间，正好也是FGO终章开放的时间，但是因为终章开放前，运营方增加了加密过程，防止科技号大量登陆，结果导致服务器崩溃了。当时自己写的服务器就特别担心要是服务器GG了，自己也就G了。好歹这段时间是过去了。</p>
<p>大概是九月份的时候吧，坐在我旁边的大佬跳槽去了头条（啥！头条也要开始做游戏了？），大佬的工作除了帮派这个功能移交给了另一个人外，剩下的几乎全给我包了。游戏里的各种福利功能，锻造、冶炼、烹饪，七七八八的。不过自己并不反感，虽然工作量多了，但是经过之前7天上班的磨练，感觉还是在自己的能力范围内。不仅把这些内容给接了，而且在11月份的时候，开始了重构过程。重构的内容主要是一些福利活动，福利活动包括常驻和非常驻。它的服务器端实现简直就是一坨shi。看了注释，好像最开始是16年一个人写的。后来旁边的头条大佬，也是日语大佬，接手了这个功能。现在我再次接手后，在掌握了这个模块功能后，开始重构。这个时候项目已经进入到了后期，几乎程序功能早已经全部实现，剩下只是美术、策划堆量的事，所以有充足的时间重构代码。啊，重构完，心情舒畅。这跟以前的代码比，不知道好了多少，哈哈。</p>
<p>期间PP也来北京滴滴实习了，PP真的是我的好朋友。当时我们有个脱宅计划，一起吃了张妈妈川菜馆，欢乐谷（水上飞车真的赤鸡），什刹海酒吧，教堂，动画原画展，书法展，11月逛了红叶岭，七七八八的事情吧。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/10.jpg" alt="image"></p>
<p>*<center>798艺术区举办的动画作品原画展</center>* </p>
<p>自己也做了一些有意思的事情，玩FGO挺喜欢艾蕾的，FHA喜欢卡莲奥尔黛西亚，然后就做了个小应用收录了人物在游戏中的语音。发布到NGA后也收获了千赞，B站粉丝涨幅高达百分之两百（笑）。不详细说了。</p>
<h2 id="2019-2-2019-2"><a href="#2019-2-2019-2" class="headerlink" title="2019.2 - 2019.2"></a>2019.2 - 2019.2</h2><p>2月公司内部发生了一些事，导致即将完成的项目被砍掉了。美术和策划几乎全走了，只有程序保留了下来。这个时候已经越来越多的公司选择UE4作为游戏开发的引擎。可能公司的下一部游戏也要换用UE4，在项目未立的这段时间，Leader让我们开始做一些技术积累，程序每人选择UE4的一个模块学习，之后做内部的技术分享。2月末是农历过年的时间点。在过年之前，坐在我后头的LY大佬分享了一些在之前游戏开发中常见到的问题，以及关于架构设计方面的一些理解。当时分享提到了守望先锋的ECS架构，之前虽然我听过这个名字，但是对内容却不甚了解。听完分享后，只觉得醍醐，这是一种和传统OOP不太一样的架构，传统的OOP太过于讲究继承、多态，但是却不是适合计算机硬件架构的设计。计算机有个cache命中率的概念，ECS为了加快这个cache的几率，让所有相同类型的数据放在一起。ECS也就是Entity、Component、System。据LY大佬说，这种架构是原来模式运行效率的七、八倍。</p>
<p>过年的前两天，也是在公司的最后一天，外卖的配送费也非常高，出去外边吃，结果发现附近的饭馆也全部关闭了。只剩下一家便利店，结果大伙纷纷拿起桶装方便面。。。 </p>
<p>过完今晚，第二天早上就要回家了吧。这是一张凌晨5、6点临走前，从房间窗户往外拍的相片。天未亮，路上排列着橙色的路灯。卧槽，我当时是故意加的一点模糊处理吗！</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/11.jpg" alt="image"></p>
<p>回到家以后，一次和妈妈去商场的时候抓了一只虾，拍了一张相。我很喜欢很愿意和妈妈早上一起去买菜，逛商场。在北京待了太久，感觉和妈妈在一起更有生活的味道。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/Graduate1th/12.jpg" alt="image"></p>
<h2 id="2019-3-2019-6"><a href="#2019-3-2019-6" class="headerlink" title="2019.3 - 2019.6"></a>2019.3 - 2019.6</h2><p>3月的时候，也就是新年结束的时候，重新开始工作了，新的美术、策划也入职了，开始做新项目的demo，一方面因为UE4确实整体项目组都掌握不够，而Unity已经是一套非常完善的实现了，决定仍然先用Unity做新游戏。下一个项目再考虑UE4。程序组只需要抽空帮助新成员融入原来的Unity项目，大部分时间仍然学习UE4。我做了一个UE4音频模块的分享，可惜效果不是很好，后来又做了UE4资源加载方面的分享。可以说3-6月中旬吧，几乎全都是研究UE4资源加载这方面，从基础API的调用到资源打包方式，然后用C++实现了UpdateResourceManager。感觉自己真的厉害，一个人把整个流程给跑完了。而且做的技术分享特地画了UML图，分享的时候也很成功。入职一年来，前半年做的Unity项目，后三分之一年学习UE4。Unity项目在我入职前底层就全部完成了，我只是在上面实现功能而已，转UE4后，学习引擎源代码，重写底层。感觉做的事情比之前在Unity做的更加有技术性一些。而且前半年刚入职，可能代码写的不够好，不够简洁，不够复用，也需要别人多帮忙。下半年竟然也能开始做一些”平等”的技术交流。重新看这一年来的日子，似乎可以稍微看到自己的进步。</p>
<p>6月中旬的时候，也就是两三个星期前吧，暂时把UE4的任务给完成了。新的项目demo也完成了。没我啥事了，正好之前Unity推出了一些新的功能，感觉有必要一学，开始学习Unity的新功能。这期间翻译了一篇关于轻量级渲染管线的技术文章。不管是从大四毕设的卡通渲染，到之前看全局光照书上的球谐函数，到现在翻译的文章，期间涉及到图形学的时候经常感觉到了自己数学能力的不足，所幸大学的线性代数的书没寄回家，翻译完文章之后就重新开始读线性代数。计划读完之后重读数学分析。</p>
<p>之前谷歌推出了云游戏的服务，随着5G的到来，如果云游戏能够实现，那么硬件不再是制约画面的因素，只有越顶级的技术未来才越能够混口饭吃。这也是继续学数学，学图形学的一个原因。</p>
<p>在完成UE4任务的时候，期间有过思考，自己未来到底想要做什么。17年秋招的时候，我跟面试官说我想要成为技术强的程序，同时也能够做技术美术的工作。技术美术是介于程序和美术的工作，偏技术向的TA（Tech and Art）会提高游戏的效率，偏美术向的可以实现更好看的效果。但是现在我似乎有一个不一样的回答。我小时候玩的武林群侠传，很多经典的游戏，它们让我想做游戏。我仅仅是想做游戏而已，如果程序不行，那我自己来编程，如果美术不行，我就去画画，如果别人有好的实现方案，我就去学习。不想再拘泥于做一个程序猿这样的想法，想做什么就去做吧。尤其是这一年来经常有这样的想法，去学一些美术方面的技能。所以后来也渐渐开始学习blender、Houdini之类的软件。过段时间了解一下，应该会买个什么来画画吧。</p>
<p>想做的事情很多，想学的东西很多。</p>
<p>言之命至，心随己愿，不忘初心，方得始终。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/2019-06-14-翻译：可编程渲染管线之定制化着色器（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/14/2019-06-14-翻译：可编程渲染管线之定制化着色器（二）/" class="post-title-link" itemprop="url">翻译：可编程渲染管线之定制化着色器（二）</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-14 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-14T00:00:00+08:00">2019-06-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-19 11:45:45" itemprop="dateModified" datetime="2019-06-19T11:45:45+08:00">2019-06-19</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>翻译：可编程渲染管线之定制化着色器（二）</p>
<p>这篇文章是翻译自<a href="https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/" target="_blank" rel="noopener">https://catlikecoding.com/unity/tutorials/scriptable-render-pipeline/custom-shaders/</a></p>
<p>关于动态批处理和GPU Instancing 可以参考<a href="https://zhuanlan.zhihu.com/p/34499251" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34499251</a></p>
<h2 id="定制化Shaders-HLSL与CoreLibrary"><a href="#定制化Shaders-HLSL与CoreLibrary" class="headerlink" title="定制化Shaders  HLSL与CoreLibrary"></a>定制化Shaders  HLSL与CoreLibrary</h2><ul>
<li>编写一个HLSL着色器</li>
<li>定义constant buffers</li>
<li>使用渲染管线Core Library</li>
<li>支持动态批处理和GPU Instancing</li>
</ul>
<p>这是Unity的可编程渲染管线系列教程的第二篇文章。本文是关于使用HLSL创建一个shader，以及在单个DrawCall里通过batch批处理，高效渲染多个物体。</p>
<p>本篇教程使用的Unity版本是 2018.3.0f2。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/1.jpg" alt="image"></p>
<p>*<center>256 spheres, a single draw call.</center>*</p>
<h3 id="1-定制Unity-Shader"><a href="#1-定制Unity-Shader" class="headerlink" title="1 定制Unity Shader"></a>1 定制Unity Shader</h3><p>虽然我们已经可以在渲染管线中使用默认的unlit shader，但是高效利用定制渲染管线，也需要创建定制化shader。所以我们将会独立创建一个shader 取代 Unity的默认的unlit shader。（nontrivial 重要的）</p>
<h4 id="1-1-创建一个shader"><a href="#1-1-创建一个shader" class="headerlink" title="1.1 创建一个shader"></a>1.1 创建一个shader</h4><p>shader资源可以通过Asset/Create/Shader 目录来创建。创建一个unlit shader好了，因为我们打算从零开始写代码，所以我们删除创建出来的shader的默认代码，并把这个资源命名为Unlit。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/2.jpg" alt="image"></p>
<p>*<center>Unlit shader asset</center>*</p>
<p>shader的基础教程在这个网址，如果你不熟悉编写shader那么就去读一读。让一个shader工作起来的最少需要定义一个shader块，这个shader块有一个属性块properties block 加上一个子着色器块subshader block（有一个pass block在 subshader里边）。在填上Shader的关键字My Pipeline/Unlit 之后，Unity会把这个shader变成一个默认的白色unlit shader 。接着就可以在材质里的shader的下拉框中找到。</p>
<pre><code>Shader &quot;My Pipeline/Unlit&quot; {
    Properties {}
    SubShader {
        Pass {}
    }
}</code></pre><p>修改Unlit Opaque材质，让它使用新的shader。这会让材质变成白色，即使shader都还没开始写。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/3.jpg" alt="image"></p>
<h4 id="1-2-HLSL"><a href="#1-2-HLSL" class="headerlink" title="1.2 HLSL"></a>1.2 HLSL</h4><p>为了编写shader，我们必须在pass块中放入一段程序。Unity支持GLSL和HLSL两种代码语言。GLSL用在默认的shader，HLSL的新渲染管线则使用了HLSL。所以我们的渲染管线也会使用HLSL。这意味着我们必须把我们的代码放在 HLSLPROGRAM 和 ENDHLSL 中间。</p>
<pre><code>        Pass {
            HLSLPROGRAM

            ENDHLSL
        }</code></pre><blockquote>
<p>GLSL 和 HLSL有什么不同呢</p>
<p>实际上，Unity为两种语言使用相同的语义（定义UnityShader专用的语言），并且根据目标平台的不同，会处理UnityShader代码转化成适合目标平台工作的shader代码的工作。</p>
<p>最大的不同点就是GLSL会隐式的include一些代码，而HLSL不会隐式的帮我们处理这些事情，这就要求我们使用HLSL的时候，需要做什么工作，就需要显式的include什么文件。这一点不错，因为旧版本的GLSL的include文件被一些老旧过时的代码给拖累的。我们将会使用更新的HLSL include文件。</p>
</blockquote>
<p>Unity的shader最少需要一个顶点函数和一个片元函数。这两个函数都用 pragma 来定义。我们定义顶点函数为 UnlitPassVertex， 片元函数为 UnlitPassFragment 。但我们不会把这两个函数的代码直接放在shader文件里。我们把HLSL文件单独放在一个“include文件”中（意思是代码放在另外一个文件里，然后shader include这个代码文件，就称代码文件为include文件）。这个include文件起名为 Unlit，以 hlsl 为后缀。把它放在和 Unlit 一样的文件夹下。在使用 pragma定义顶点函数、片元函数后，就可以include这个文件了。</p>
<pre><code>            HLSLPROGRAM

            #pragma vertex UnlitPassVertex
            #pragma fragment UnlitPassFragment

            #include &quot;Unlit.hlsl&quot;

            ENDHLSL</code></pre><p>不幸的是，Unity并没有一个方便的选项来让我们创建 hlsl 文件资源。我们必须自己来创建，例如通过复制 Unlit.shader 文件，然后改拓展名，再把shader代码移除。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/4.jpg" alt="image"></p>
<p>*<center>Unlit HLSL include file asset</center>*</p>
<p>在这个include文件里（也就是编写顶点函数、片元函数的 hlsl 文件），会设置一个 guard 标志来避免这个文件在被include多次的情况下产生重复代码。最好在每一个include文件都这么做。</p>
<pre><code>#ifndef MYRP_UNLIT_INCLUDED
#define MYRP_UNLIT_INCLUDED

#endif // MYRP_UNLIT_INCLUDED</code></pre><p>（弄完文件之后就是具体的编写hlsl代码了）</p>
<p>在顶点函数中，我们最少需要知道顶点位置，顶点位置是必须输出到裁剪空间位置的。所以我们为顶点函数定义两个结构体，input结构体和output结构体。这两个结构体都带有一个 float4的变量，表示位置。</p>
<pre><code>#ifndef MYRP_UNLIT_INCLUDED
#define MYRP_UNLIT_INCLUDED

struct VertexInput {
    float4 pos : POSITION;
};

struct VertexOutput {
    float4 clipPos : SV_POSITION;
};

#endif // MYRP_UNLIT_INCLUDED</code></pre><p>接着我们来实现 UnlitPassVertex 这个顶点函数。现在我们直接把局部空间的顶点位置输出为裁剪空间的位置。这是不正确的空间转换，但这是最快的方式来获取一个编译好的shader。我们将在稍后纠正。</p>
<pre><code>struct VertexOutput {
    float4 clipPos : SV_POSITION;
};

VertexOutput UnlitPassVertex (VertexInput input) {
    VertexOutput output;
    output.clipPos = input.pos;
    return output;
}

#endif // MYRP_UNLIT_INCLUDED</code></pre><p>（在片元函数里）目前我们保持输出颜色为默认的白色即可。所以片元处理函数只需要返回一个 1，float4 类型的值。顶点函数的输出后作为片元函数的输入，所以要把它作为参数，即使我们现在用不到。</p>
<pre><code>VertexOutput UnlitPassVertex (VertexInput input) {
    VertexOutput output;
    output.clipPos = input.pos;
    return output;
}

float4 UnlitPassFragment (VertexOutput input) : SV_TARGET {
    return 1;
}

#endif // MYRP_UNLIT_INCLUDED</code></pre><blockquote>
<p>我们是否使用half 或者 float</p>
<p>大部分移动设备GPU都支持这两种precision types精度类型， half会更加高效一些。所以如果你正在为移动设备做优化工作，那么应该尽可能的使用half。 如果结果是可以接收的情况下,那么一般规则是 只对positions位置和texture coordinate纹理坐标使用float，其他的则全部用half。（The rule is to use <strong>float</strong> for positions and texture coordinate only and <strong>half</strong> for everything else, provided that the results are acceptable.）</p>
<p>（Provided that 如果是、假如）</p>
<p>如果目标不是移动平台，精度并不是一个大问题。因为GPU总是会使用float，即使我们写half也是一样。之后的教程基本都是写float的。</p>
<p>其实还有一个fixed精度，但它只被一些比较老的设备支持，基本上现在的app不会考虑安装在这些设备上，（所以基本可以忽略了），fixed这个精度通常是等同于half的。</p>
</blockquote>
<h4 id="1-3-Transformation-Matrices-矩阵变换"><a href="#1-3-Transformation-Matrices-矩阵变换" class="headerlink" title="1.3 Transformation Matrices 矩阵变换"></a>1.3 Transformation Matrices 矩阵变换</h4><p>现在我们有了一个编译成功的shader了，但它尚未产生正确的结果。下一步就是把顶点位置转化到正确的空间位置。如果我们有一个MVP矩阵，我们可以直接从局部空间转化到裁剪空间，但Unity并没有为我们提供这么一个矩阵，Unity为我们提供了局部空间到世界空间的矩阵。Unity希望我们的shader有一个 float4*4 的unity_ObjectToWorld 变量来存储矩阵。因为我们是用HLSL工作的，所以我们必须自己来定义这个变量。然后才可以在顶点函数中使用它转化位置到世界空间的位置，并使用这个世界空间的位置作为输出结果。</p>
<pre><code>float4x4 unity_ObjectToWorld;

struct VertexInput {
    float4 pos : POSITION;
};

struct VertexOutput {
    float4 clipPos : SV_POSITION;
};

VertexOutput UnlitPassVertex (VertexInput input) {
    VertexOutput output;
    float4 worldPos = mul(unity_ObjectToWorld, input.pos);
    output.clipPos = worldPos;
    return output;
}</code></pre><p>接着我们需要转化世界空间到裁剪空间。这个工作可以被VP矩阵完成。Unity也为我们提供了float4*4 unity_MatrixVP 变量来作为VP矩阵，这样就完成了空间转化</p>
<pre><code>float4x4 unity_MatrixVP;
float4x4 unity_ObjectToWorld;

…

VertexOutput UnlitPassVertex (VertexInput input) {
    VertexOutput output;
    float4 worldPos = mul(unity_ObjectToWorld, input.pos);
    output.clipPos = mul(unity_MatrixVP, worldPos);
    return output;
}</code></pre><blockquote>
<p>我修改了代码，但它还没有生效？</p>
<p>在编辑include文件的时候，Unity并不总是会对更改做出反应，这样就不会刷新shader了。这种情况发生的时候，再次尝试保存文件，如果有必要可以做一点后退操作</p>
</blockquote>
<p>我们的shader现在已经正确执行了。所有使用这个 unlit material 的物体又是可见的了，显示为白色。但是我们的空间转化可以更加高效，因为空间转化是使用一个4D的位置向量来做矩阵乘法。向量的第四个值总是为1，通过显式声明，我们可以使编译器优化计算。</p>
<pre><code>float4 worldPos = mul(unity_ObjectToWorld, float4(input.pos.xyz, 1.0));v</code></pre><h4 id="1-4-Constant-Buffer-常量缓存区"><a href="#1-4-Constant-Buffer-常量缓存区" class="headerlink" title="1.4 Constant Buffer 常量缓存区"></a>1.4 Constant Buffer 常量缓存区</h4><p>Unity并没有为我们提供MVP矩阵，因为 M 和 VP 矩阵的相乘是避免的。除此之外， VP矩阵能够被同一帧内，被同一个摄像机所绘制的所有物体所复用。Unity着色器利用了这一点并且把这个矩阵放在一个Constant Buffer中。虽然我们定义它们为变量，但是它们的数据在绘制一个图形的时间段内是保持常量的。通常会保持更长的时间段。VP矩阵被放入一个 per-frame的缓冲区中，而 M 矩阵则被放入一个 per-draw 的缓冲区中。（每次调用Draw命令，per-draw缓冲区内容保持不变。per-frame 同理，在同一帧内 VP矩阵保持不变，实现复用）。</p>
<p>虽然并没有严格要求把shader变量放在Constant Buffer中，但这么做确实可以更有效地修改在相同常量缓冲区的数据。至少在图形API的支持下是这种情况的（指HLSL），OpenGL则不是这样。</p>
<p>为了尽可能地高效，我们也会利用Constant Buffer。Unity把 VP矩阵放在 UnityPerFrame的cbuffer中，把 M 矩阵放在 UnityPerDraw的CBuffer中。其实有更多的数据放在这些cbuffer中，但在我们的渲染管道里暂时还不需要这么做。除了cbuffer关键字不同，一个cbuffer的定义就像struct一样，其中变量也保持是可以被访问的。</p>
<pre><code>cbuffer UnityPerFrame {
    float4x4 unity_MatrixVP;
};

cbuffer UnityPerDraw {
    float4x4 unity_ObjectToWorld;
}</code></pre><h4 id="1-5-Core-Library"><a href="#1-5-Core-Library" class="headerlink" title="1.5 Core Library"></a>1.5 Core Library</h4><p>因为cbuffer并没有使所有平台受益，所以Unity的shader依赖宏，这些宏只有在需要的时候才使用它们。比起直接写cbuffer，我们使用 CBUFFER_START 宏加上一个名字参数来替代。对应的CBUFFER_END宏取代了原本cbuffer的结束方式。</p>
<p>（意思是cbuffer得谨慎使用吧，感觉cbuffer复用得好应该所有平台都能有收益才对，这么说的话，可能有一些隐含的问题？ ）</p>
<pre><code>CBUFFER_START(UnityPerFrame)
    float4x4 unity_MatrixVP;
CBUFFER_END

CBUFFER_START(UnityPerDraw)
    float4x4 unity_ObjectToWorld;
CBUFFER_END</code></pre><p>上面的这种写法会导致一个编译错误。因为这两个宏还没有被定义。比起弄明白什么时候是合适的情况来使用cbuffer和我们自己来定义宏，我们更倾向于利用Unity的Core Library。CoreLibrary可以通过PackageManagerWindow来添加到我们的项目中。转到 AllPackages liebiao ，在Advanced下启用Show preview packages。然后选择 Render-pipelines.core 然后安装它。我正在使用4.6.0的预览版，Unity2018.3会使用更高的版本。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/5.jpg" alt="image"></p>
<p>现在我们可以include 包含进 common library functionality 公共库函数。我们可以访问通过<em>Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl</em>. 它定义了多个有用的函数和宏，还有许多cbuffer的宏，所以在使用这些定义好的宏前 先include它吧</p>
<pre><code>#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;

CBUFFER_START(UnityPerFrame)
float4x4 unity_MatrixVP;
CBUFFER_END</code></pre><blockquote>
<p>这些宏是如何工作的呢？</p>
<p>通过打开core library package的 Common.hlsl 文件，我们可以就能了解宏是如何生效的。原来Common.hlsl从它的API子文件夹中include了许多 特定API的文件。这些文件定义了宏。</p>
</blockquote>
<h4 id="1-6-Compilation-Target-Level"><a href="#1-6-Compilation-Target-Level" class="headerlink" title="1.6  Compilation Target Level"></a>1.6  Compilation Target Level</h4><p>我们的shader再一次生效了，至少对大部分平台而言。在include core library之后，我们的shader在OpenGL ES2 上编译失败。 这确实会发生，因为默认情况下Unity 对OpenGL ES 2使用一个shader编译器，这个shader编译器与core library一起时是不生效的。修复这个问题可以通过向shader中添加一句</p>
<p><strong>#pragma prefer_hlslcc gles</strong> </p>
<p>增加上述这一句代码，这也是Unity在LWRP 轻量级渲染管线的做法。可以比起这么做，我们选择不支持OpenGL ES2 。 因为OpenGL ES 2 应用于一些老的移动设备。</p>
<p>我们选择目标平台 通过这一句代码 <strong>#pragma target</strong>  直接指定为3.5 而不是默认的level 2.5</p>
<pre><code>            #pragma target 3.5

            #pragma vertex UnlitPassVertex
            #pragma fragment UnlitPassFragment</code></pre><h4 id="1-7-Folder-Struct-文件夹结构"><a href="#1-7-Folder-Struct-文件夹结构" class="headerlink" title="1.7 Folder Struct 文件夹结构"></a>1.7 Folder Struct 文件夹结构</h4><p>注意 core library 的所有 HLSL的 include文件全都放在ShaderLibrary文件夹下。我们也在My Pipeline的文件夹下新建一个ShaderLibrary并且把Unlit.hlsl放入这个文件夹。shader文件则放在一个单独的文件夹Shader下。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/6.jpg" alt="image"></p>
<p>*<center>我的渲染管线文件夹目录结构</center>*</p>
<p>为了保持我们的shader不受目录结构变化的影响，同时仍然依赖于相对路径，我们必须修改include statement，include之后的这一句声明，从原本的 Unlit.hlsl 修改成”../ShaderLibrary/Unlit.hlsl”。</p>
<pre><code>            #include &quot;../ShaderLibrary/Unlit.hlsl&quot;</code></pre><h2 id="2-Dynamic-Batching-动态批处理"><a href="#2-Dynamic-Batching-动态批处理" class="headerlink" title="2 Dynamic Batching 动态批处理"></a>2 Dynamic Batching 动态批处理</h2><p>既然我们已经有了一个基本的shader，我们可以用它来进一步研究如何让我们的管线渲染物体。一个问题是它的渲染能多高效？我们通过在场景中填充一堆使用一堆白色球体来测试，每一个球体都会使用 unlit shader，也就是我们之前定义的材质。可以使用几千个球体来测试，但是几十个也行。他们可以有有不同的transformation，但是scale必须统一，就是说XYZ必须相等。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/7.jpg" alt="image"></p>
<p>*<center>一堆白色的球体</center>*</p>
<p>在通过frame debugger调查这个场景是如何被绘制的时候，我们能注意到每一个球体需要单独的draw call。这不是高效的，因为每个draw call都会引入开销，这部分开销来自于CPU与GPU交流信息的时候。理想情况下，多个球体能通过一个draw call来绘制。这是可行的。选中frame debugger的一条draw call，会给了我们一条提示。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/8.jpg" alt="image"></p>
<p>（补充一点，通常绘制一个物体分为两个阶段，一是CPU往GPU传递数据，设置渲染状态，称为setpass。二是GPU开始调用数据绘制图形。其中第一阶段的消耗占整个过程比第二阶段的消耗大很多，所以优化的方向就是减少CPU、GPU传递数据的次数。如果有多个可见相同物体，那么可以考虑把它们给批处理一下，多个drawcall合并成一个drawcall，这样CPU、GPU就只传递了一次数据，完成了多个物体的绘制。</p>
<p>批处理还可以分为静态批处理和动态批处理，不管是哪一种批处理也是有限制的，静态批处理会增大内存，动态批处理是有顶点限制的。而且传递给GPU的数据也不是越多越好，也必须考虑GPU的处理能力。</p>
<p>批处理的对象如果大部分不可见，那么传递整批顶点数据过去其实也是不必要的。所以批处理的使用得考虑实际情况。）</p>
<h4 id="2-1-Enabling-Batching-开启批处理"><a href="#2-1-Enabling-Batching-开启批处理" class="headerlink" title="2.1 Enabling Batching 开启批处理"></a>2.1 Enabling Batching 开启批处理</h4><p>frame debugger告诉我们动态批处理没有被使用，坑你是因为在PlayerSetting是关闭的，或者是因为深度排序的接口。 检查PlayerSetting，其中的Dynamic Batching这个选项是关闭的，但是开启的话也没有起作用。因为PlayerSetting是对Unity默认渲染管线起作用的。我们这个是定制的渲染管线。</p>
<p>为了给我们的渲染管线开启动态批处理，我们必须声明在渲染管线的渲染器绘制的时候，动态批处理是允许的。drawsetting包含一个 flags 的字段，我们必须设置这个 flags 为允许动态批处理。如下</p>
<pre><code>        var drawSettings = new DrawRendererSettings(
            camera, new ShaderPassName(&quot;SRPDefaultUnlit&quot;)
        );
        drawSettings.flags = DrawRendererFlags.EnableDynamicBatching;
        drawSettings.sorting.flags = SortFlags.CommonOpaque;</code></pre><p>在修改完后动态批处理仍然没有生效，但是提示的原因改变了。动态批处理即在物体被绘制前，unity把物体合并到一个mesh中。它是要求每一帧中消耗CPU时间去处理，而且这仅对small mesh有效。（也就是说物体顶点数太多是无法动态批处理的）。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/9.jpg" alt="image"></p>
<p>*<center>Too many vertices to batch</center>*</p>
<p>球体的网格顶点数太多了，方块是足够小的，修改所有物体成方块。可以通过选中全体然后修改它们的mesh filter。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/10.jpg" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/11.jpg" alt="image"></p>
<h4 id="2-2-Colors-多种颜色"><a href="#2-2-Colors-多种颜色" class="headerlink" title="2.2 Colors 多种颜色"></a>2.2 Colors 多种颜色</h4><p>动态批处理对于多个使用相同材质的小网格来说是生效的。但是涉及多个材质的时候，问题也就变得复杂了。为了说明这个情况，让unlit shader可以去修改颜色。增加一个颜色属性到它的 Properties block 属性块中，名字叫做“Color”，默认白色。 </p>
<pre><code>    Properties {
        _Color (&quot;Color&quot;, Color) = (1, 1, 1, 1)
    }</code></pre><p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/12.jpg" alt="image"></p>
<p>现在我们就可以来调整材质的颜色了，但还没有产生影响。我们增加一个 float4 _Color 的变量到我们的include文件中，之前我们是在unlitPassFragment片元函数中返回一个固定值，现在让函数返回这个颜色值。每一个材质都定义了一个颜色属性，所以颜色属性可以放在cbuffer，只在切换材质的时候，才需要改变这个cbuffer。这个cbuffer起名为UnityPerMaterial。</p>
<pre><code>CBUFFER_START(UnityPerDraw)
    float4x4 unity_ObjectToWorld;
CBUFFER_END

CBUFFER_START(UnityPerMaterial)
    float4 _Color;
CBUFFER_END

struct VertexInput {
    float4 pos : POSITION;
};

…

float4 UnlitPassFragment (VertexOutput input) : SV_TARGET {
    return _Color;
}</code></pre><p>复制材质并设置不同的颜色，以便于区分它们。选中一些物体让它们使用新的材质。最后能看到场景中是两种颜色的方块混合在一起。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/13.jpg" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/14.jpg" alt="image"></p>
<p>*<center>Two materials, four batches.</center>*</p>
<p>动态批处理仍然是生效的，但我们是饿到多个批处理。每个材质至少会有一个批处理，因为每一个批处理都要求不同的材质数据。通常会有更多批处理因为Unity倾向于在空间上组合物体来减少overdraw。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/15.jpg" alt="image"></p>
<p>*<center>No batching because of different materials.</center>*</p>
<h4 id="2-3-Optional-Batching-可选的批处理"><a href="#2-3-Optional-Batching-可选的批处理" class="headerlink" title="2.3 Optional Batching  可选的批处理"></a>2.3 Optional Batching  可选的批处理</h4><p>动态批处理可能会有帮助，但它也有可能没有那么大的效果，甚至可能降低效率。如果你的场景没有包含大量包含相同材质的小网格，可能关闭动态批处理会更加的合理，Unity也就不必知道是否要在每帧使用批处理技术。 所以我们增加了一个选项，我们的渲染管线是否开启动态批处理。我们的渲染管线并不使用PlayerSetting，所以我们增加了一个配置选项到 MyPipelineAsset。我们可以在Editor通过pipeline资源来配置这项数据。</p>
<pre><code>    [SerializeField]
    bool dynamicBatching;</code></pre><p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/16.jpg" alt="image"></p>
<p>*<center>Dynamic batching enabled.</center>*</p>
<p>在MyPipeline实例创建的时候，我们必须告诉它是否要使用动态批处理。我们会通过在它的构造函数中通过函数参数来提供这项信息。</p>
<pre><code>    protected override IRenderPipeline InternalCreatePipeline () {
        return new MyPipeline(dynamicBatching);
    }</code></pre><p>我们不在使用MyPipeline的默认构造函数了，我们提供一个带有boolean值作为参数的公共构造方法。boolean值用来控制是否开启动态批处理。我们在构造函数设置draw flags，并记录在一个字段中。</p>
<pre><code>    DrawRendererFlags drawFlags;

    public MyPipeline (bool dynamicBatching) {
        if (dynamicBatching) {
            drawFlags = DrawRendererFlags.EnableDynamicBatching;
        }
    }</code></pre><p>在render中把flags设置到draw setting。</p>
<pre><code>        drawSettings.flags = drawFlags;</code></pre><p>注意在编辑器下调整了MyPipeline的动态批处理的选项，Unity是否批处理会立即生效。每次我们调整，都会导致创建出一个新的渲染管线实例。</p>
<h2 id="3-GPU-Instancing"><a href="#3-GPU-Instancing" class="headerlink" title="3 GPU Instancing"></a>3 GPU Instancing</h2><p>动态批处理性不是我们在每帧中减少draw call的唯一方式。另外一种方式是使用GPU instancing。GPU instancing也就是CPU通知GPU在一个 draw call 中多次去绘制一个明确的“网格材质”。这样就可以结合那些使用同一网格和材质的物体，同时不需要构建一个新的网格。而且也取消了网格大小的限制。</p>
<p>（</p>
<p>摘抄</p>
<p>虽然实例化的物体共享相同的网格和材质，但您可以使用MaterialPropertyBlock API为每一个物体设置单独的着色器属性。</p>
<p>）</p>
<h4 id="3-1-Optional-Instancing-是否启用GPU实例化"><a href="#3-1-Optional-Instancing-是否启用GPU实例化" class="headerlink" title="3.1 Optional Instancing 是否启用GPU实例化"></a>3.1 Optional Instancing 是否启用GPU实例化</h4><p>GPU instancing 是默认开启的。我们需要覆写它，这样就方便比较开启或不开启，两种情况下的结果。给MyPipeline资源增加一个新的选项，在脚本里添加一个字段，并且修改构造函数。</p>
<pre><code>    [SerializeField]
    bool instancing;

    protected override IRenderPipeline InternalCreatePipeline () {
        return new MyPipeline(dynamicBatching, instancing);
    }</code></pre><p>在MyPipeline的构造函数中，也为GPU instancing设置标志位。flags的值是DrawRenderFlags.EnableInstancing。我们通过操作符“ | ”传递到drawflags。这样动态批处理和GPU Instancing就同时开启了。在它们都开启的情况下，Unity更倾向于GPU Instancing。</p>
<pre><code>    public MyPipeline (bool dynamicBatching, bool instancing) {
        if (dynamicBatching) {
            drawFlags = DrawRendererFlags.EnableDynamicBatching;
        }
        if (instancing) {
            drawFlags |= DrawRendererFlags.EnableInstancing;
        }
    }</code></pre><p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/17.jpg" alt="image"></p>
<p>*<center>Instancing enabled, dynamic batching disabled.</center>*</p>
<h4 id="3-2-Material-Support-材质支持"><a href="#3-2-Material-Support-材质支持" class="headerlink" title="3.2 Material Support 材质支持"></a>3.2 Material Support 材质支持</h4><p>GPU实例化 开启了并不意味这objects会自动实例化。它还必须被材质所支持。因为实例化并不总是需要的。它是可选的，这要求两个shader的变体。一个支持实例化另一个不支持。我们可以创建要求的shader变体通过添加一句代码到我们的shader中 #pragma multi_compile_instancing 。这产生了两个shader变体，其中一个变体定义了 INSTANCING_ON关键字，另一个则没有。</p>
<pre><code>        #pragma target 3.5

        #pragma multi_compile_instancing

        #pragma vertex UnlitPassVertex
        #pragma fragment UnlitPassFragment</code></pre><p>修改了shader后，材质也相应的出现了一个新的配置选项：Enable GPU Instancing。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/18.jpg" alt="image"></p>
<p>*<center>Material with instancing enabled.</center>*</p>
<h4 id="3-3-Shader-Support-着色器支持"><a href="#3-3-Shader-Support-着色器支持" class="headerlink" title="3.3 Shader Support 着色器支持"></a>3.3 Shader Support 着色器支持</h4><p>在GPU Instancing开启的情况下，GPU使用相同的constant data，多次去绘制相同的mesh。但是 M 矩阵也是这一部分数据的一部分。但是每个物体应该有不同的M矩阵。为了解决这个问题，一个包含许多矩阵的数组必须被放在cbuffer中，每个实例被绘制的时候使用自己独特的索引，这个索引能用来从矩阵数组中取到正确的m矩阵。</p>
<p>现在存在两种情况，在不启用GPU Instancing的情况下，我们使用unity_ObjectToWorld。启用GPU Instancing的情况下使用矩阵数组。为了保持在两种情况下的顶点函数的代码相同，我们会为矩阵定义一个宏 UNITY_MATRIX_M，因为CoreLibrary有一个includefile 已经为我们定义了宏来支持GPU Instancing. 它也重新定义了UNITY_MATRIX_M 来使用矩阵数组。</p>
<p>（也就是说没有开启GPU 实例化的时候，我们把UNITY_MATRIX_M 定义了，开启GPU实例化的时候，因为core库由一个包含文件include file ，这个文件也定义了相关的宏，其中定义的一个宏UNITY_MATRIX_M 就应用了帮我们从矩阵数组中取出我们需要的矩阵的方法。）</p>
<pre><code>CBUFFER_START(UnityPerDraw)
    float4x4 unity_ObjectToWorld;
CBUFFER_END

#define UNITY_MATRIX_M unity_ObjectToWorld

…

VertexOutput UnlitPassVertex (VertexInput input) {
    VertexOutput output;
    float4 worldPos = mul(UNITY_MATRIX_M, float4(input.pos.xyz, 1.0));
    output.clipPos = mul(unity_MatrixVP, worldPos);
    return output;
}</code></pre><p>CoreLibrary的include文件就是 UnityInstancing.hlsl ，因为它可能定义了 UNITY_MATRIX_M，我们必须在定义我们的宏之后才把它include进来。（这样如果启用GPU Instancing，include文件就会覆盖之前的UNITY_MATRIX_M的定义）</p>
<pre><code>#define UNITY_MATRIX_M unity_ObjectToWorld

#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl&quot;</code></pre><p>在使用GPU实例化的时候，被绘制的物体的索引被GPU添加到它的VertexData顶点数据中。UNITY_MATRIX_M是依赖于这个索引的，所以我们必须添加索引到VertexInput的结构体中，我们可以使用UNITY_VERTEX_INPUT_INSTANCE_ID 这个宏来记录这个索引。</p>
<pre><code>struct VertexInput {
    float4 pos : POSITION;
    UNITY_VERTEX_INPUT_INSTANCE_ID
};</code></pre><p>在使用UNITY_MATRIX_M这个宏之前必须获得物体的索引。可以通过UNITY_SETUP_INSTANCE_ID 这个宏来获得，这个宏需要一个input作为参数。</p>
<pre><code>VertexOutput UnlitPassVertex (VertexInput input) {
    VertexOutput output;
    UNITY_SETUP_INSTANCE_ID(input);
    float4 worldPos = mul(UNITY_MATRIX_M, float4(input.pos.xyz, 1.0));
    output.clipPos = mul(unity_MatrixVP, worldPos);
    return output;
}</code></pre><p>我们的方块们现在就是通过GPU Instancing的方式来绘制的了。像动态批处理一样，因为我们使用了不同的材质，所以最后绘制过程仍然是使用了几个批处理。要确保所有的材质都使用了GPU Instancing。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/19.jpg" alt="image"></p>
<p>*<center>Four instanced draw calls.</center>*</p>
<p>除了局部空间到世界空间的矩阵，默认地，世界到局部空间的矩阵也被放在实例化Buffer中，这些是M矩阵的逆矩阵。在使用non-uniform scales 的时候，法线向量需要这些数据。但我们只使用uniform scales ，所以我们不需要这些额外的矩阵，我们可以通过增加这句代码到shader中来告诉Unity这一点，#pragma instancing_options assumeuniformscaling</p>
<pre><code>            #pragma multi_compile_instancing
            #pragma instancing_options assumeuniformscaling</code></pre><p>如果要支持non-uniform scale的时候 就必须使用一个没有开启这个选项的shader</p>
<p>（也就是说如果物体有缩放操作的时候不能使用GPU Instancing呗。）</p>
<h4 id="3-4-许多颜色"><a href="#3-4-许多颜色" class="headerlink" title="3.4 许多颜色"></a>3.4 许多颜色</h4><p>如果我们想要在我们的场景中容纳更多颜色，我们需要更多的材质！这也就意味着会有更多的batches。但是如果矩阵可以被放在一个cbuffer数组中，那么对于颜色来说 这应该也是有可能做到的。那么我们就可以把带有不同颜色的object 合并在单个batch中。只需要一些额外工作，这就可以被做到。</p>
<p>要支持每一个物体有一个独特的颜色首先要让每一个物体设置一个颜色成为可能。我们无法通过材质做到。因为这是一个所有objects 共享的一个资源。让我们为每一个object创建一个component吧，名字叫做InstancedColor，给它一个可配置的颜色字段。因为它对渲染管线来说不是特定的，所以把它的脚本文件保存在MyPipeline 文件夹外边。</p>
<pre><code>using UnityEngine;

public class InstancedColor : MonoBehaviour {

    [SerializeField]
    Color color = Color.white;
}</code></pre><p>为了覆写材质的颜色，我们必须提供带有材质属性块的物体渲染器。（To overriede the material’s color, we have to provide the object’s renderer component with a material property block。）创建一个新的 MaterialPropertyBlock 实例，通过SetColor方法给这个属性块一个_Color属性，然后传递它到物体的网格渲染器组件。假设在play模式下（就是点击播放按钮之后），物体的颜色保持不变。所以我们的代码要写在Awake方法中。</p>
<pre><code>    void Awake () {
        var propertyBlock = new MaterialPropertyBlock();
        propertyBlock.SetColor(&quot;_Color&quot;, color);
        GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(propertyBlock);
    }</code></pre><p>把InstancedColor组件添加到物体上，这样就可以看到颜色变化了。但是仅仅只在我们进入play mode的时候。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/20.jpg" alt="image"></p>
<p>*<center>Cube with color component.</center>*</p>
<p>为了在edit mode模式下马上在场景中看到颜色改变，把设置颜色的相关代码移动到OnValidate方法。Awake方法能调用这个OnValidate方法，所以脚本中不必复制代码。</p>
<pre><code>    void Awake () {
        OnValidate();
    }

    void OnValidate () {
        var propertyBlock = new MaterialPropertyBlock();
        propertyBlock.SetColor(&quot;_Color&quot;, color);
        GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(propertyBlock);
    }</code></pre><blockquote>
<p>OnValidate什么时候调用呢？</p>
<p>OnValidate是一个特殊的Unity的message方法。仅在edit模式，在component被加载或者改变的时候被调用。所以每次场景被加载的时候以及我们编辑component的时候，颜色就立即发生了改变。</p>
</blockquote>
<p>选中所有物体添加一次组件这样就增加这个component到每个物体上，但是要确保已经存在这个组件的物体不会被重复添加组件。也让它们全部使用同样的材质。之前复制出来的另一个材质就可以被移除了，因为我们为每一个物体配置一个颜色。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/21.jpg" alt="image"></p>
<p>*<center>Many colors, one material.</center>*</p>
<p>注意在InstancedColor组件中，我们每次设置一个颜色覆盖之前的颜色设置，都是创建一个新的MaterialPropertyBlock的实例。这不是必要的。因为每一个网格渲染器从属性块中拷贝数据，并记录到覆写的属性。这表明我们可以复用MaterialPropertyBlock，所以我们记录一个静态字段，只在需要的时候才创建它。</p>
<pre><code>    static MaterialPropertyBlock propertyBlock;

    …

    void OnValidate () {
        if (propertyBlock == null) {
            propertyBlock = new MaterialPropertyBlock();
        }
        propertyBlock.SetColor(&quot;_Color&quot;, color);
        GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(propertyBlock);
    }</code></pre><p>而且我们能稍微加速颜色属性的匹配通过提前取回它的属性ID，通过Shader.PropertyToID方法。每一个shader的属性名字有一个全局的标识符int值。这些的标识符可能发生改变，但是在单个session期间是保持常量的，即在play和compilation之间。（session是指点击play开始游戏 到 编译代码的这一个过程。就是每次运行可能不同，但是单次运行游戏是保持常量的。把这个值记录为静态int值。）所以我们取到它一次，并作为静态字段的默认值存储记录起来。</p>
<pre><code>    static int colorID = Shader.PropertyToID(&quot;_Color&quot;);

    …

    void OnValidate () {
        if (propertyBlock == null) {
            propertyBlock = new MaterialPropertyBlock();
        }
        propertyBlock.SetColor(colorID, color);
        GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(propertyBlock);
    }</code></pre><h4 id="3-5-Per-Instance-Colors-每个物体实例都有一个单独的颜色"><a href="#3-5-Per-Instance-Colors-每个物体实例都有一个单独的颜色" class="headerlink" title="3.5 Per-Instance Colors 每个物体实例都有一个单独的颜色"></a>3.5 Per-Instance Colors 每个物体实例都有一个单独的颜色</h4><p>覆写每个物体的颜色字段导致GPU实例化被破坏。 虽然我们使用同样一个材质，但是重要的是被用于渲染的数据。因为我们已经为每个物体覆写了颜色，我们已经强制它们被分开绘制。</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/22.jpg" alt="image"></p>
<p>*<center>Not instanced because of color differences.</center>*</p>
<p>我们把颜色信息放在array数组里边，这可以让GPU Instancing重新生效。我们的_Color属性必须像M矩阵一样使用同样的处理方式。这种情况下，我们必须显式声明。因为core库不会为任意属性而重定义宏。（arbitrary 任意的 武断的 专制的）我们手动创建一个cbuffer，通过UNITY_INSTANCE_BUFFER_START 和对应的结束宏。取名为PerInstance。在cbuffer内，我们定义 UNITY_DEFINE_INSTANCED_PROP(float4, _Color)。在没有使用GPU Instancing的时候，这就相当于一个普通的声明变量的式子 float4 _Color。如果启用GPU Instancing，就是得到一个实例数据的数组。</p>
<pre><code>//CBUFFER_START(UnityPerMaterial)
    //float4 _Color;
//CBUFFER_END

UNITY_INSTANCING_BUFFER_START(PerInstance)
    UNITY_DEFINE_INSTANCED_PROP(float4, _Color)
UNITY_INSTANCING_BUFFER_END(PerInstance)</code></pre><p>（通过上述的方法，就有两种得到颜色的方式了。当前情形可能是两种其中之一。）为了解决这个问题，我们必须通过宏 UNITY_ACCESS_INSTANCED_PROP 来访问数据，cbuffer和属性名字作为宏的参数。</p>
<pre><code>float4 UnlitPassFragment (VertexOutput input) : SV_TARGET {
    return UNITY_ACCESS_INSTANCED_PROP(PerInstance, _Color);
}</code></pre><p>在UnlitPassFragment的片元函数中，必须得到实例的索引。所以在VertexOutput中增加一个宏 UNITY_VERTEX_INPUT_INSTANCE_ID。（之前在顶点函数中使用过UNITY_SETUP_INSTANCE_ID这个宏来取得实例索引）现在再次使用这个宏UNITY_SETUP_INSTANCE_ID。为了让它生效我们必须把index索引从vertex input 拷贝到vertex output，可以通过 UNITY_TRANSFER_INSTANCE_ID 这个宏来实现。</p>
<pre><code>struct VertexInput {
    float4 pos : POSITION;
    UNITY_VERTEX_INPUT_INSTANCE_ID
};

struct VertexOutput {
    float4 clipPos : SV_POSITION;
    UNITY_VERTEX_INPUT_INSTANCE_ID
};

VertexOutput UnlitPassVertex (VertexInput input) {
    VertexOutput output;
    UNITY_SETUP_INSTANCE_ID(input);
    UNITY_TRANSFER_INSTANCE_ID(input, output);
    float4 worldPos = mul(UNITY_MATRIX_M, float4(input.pos.xyz, 1.0));
    output.clipPos = mul(unity_MatrixVP, worldPos);
    return output;
}

float4 UnlitPassFragment (VertexOutput input) : SV_TARGET {
    UNITY_SETUP_INSTANCE_ID(input);
    return UNITY_ACCESS_INSTANCED_PROP(PerInstance, _Color);
}</code></pre><p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/23.jpg" alt="image"></p>
<p>*<center>Many colors, one draw.</center>*</p>
<p>所有的物体最终都被合并到一个draw call中了，即使他们使用了不同的颜色。可是仍然存在一个限制，多少数据能被放入cbuffer中呢？（ The maximum instance batch size depends on how much data we vary per instance）（这一句不太好翻译，可能有些绕口，如果CPU提交一次数据到GPU是它所说的batch，那意思是最大的提交数据量取决于我们让每个实例有多大的数据变化量）除此之外，buffer的最大值根据平台的不同也是不同的。而且我们仍然受限于使用同一个网格和材质。例如混用方块和球体会导致分离出几个批处理。</p>
<p>（这段话意思是在讲cbuffer能存放多少数据，但是文章并没有直接回答，而是列举了几种情况，目的是想说能放多少数据真不太好说，如果使用越多个数据的变化量，那么cbuffer也就越大。平台的不同也有关系。混用不同mesh也有关系。）</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/24.jpg" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/TranslationSRP1/25.jpg" alt="image"></p>
<p>*<center>Both cubes and spheres.</center>*</p>
<p>现在我们有了一个最小的shader ，这个shader能用于高效绘制许多物体。之后我们会基于此创建更多高级的shader</p>
<p>In the future, we will build on this foundation to create more advanced shaders.</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/12/2019-06-12-UE4安卓打包问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/12/2019-06-12-UE4安卓打包问题/" class="post-title-link" itemprop="url">UE4安卓打包问题</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-12T00:00:00+08:00">2019-06-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-14 10:14:45" itemprop="dateModified" datetime="2019-06-14T10:14:45+08:00">2019-06-14</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="记录一些安卓打包的问题"><a href="#记录一些安卓打包的问题" class="headerlink" title="记录一些安卓打包的问题"></a>记录一些安卓打包的问题</h2><h4 id="Enable-Gradle-instead-of-Ant-取消勾选"><a href="#Enable-Gradle-instead-of-Ant-取消勾选" class="headerlink" title="Enable Gradle instead of Ant 取消勾选"></a>Enable Gradle instead of Ant 取消勾选</h4><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPackaging/1.jpg">



<h4 id="SDK相关"><a href="#SDK相关" class="headerlink" title="SDK相关"></a>SDK相关</h4><p>按照官网的打包提示，下载SDK需要使用一个叫CodeWorksforAndroid-xxxx的文件。文件地址在UE4的引擎工程下Engine/Extras/AndroidWorks/Win64文件夹下。随着现在UE4版本更新这个文件也在更新，但是中文文档的官网还显示老版的安装教程。官网说明和实际使用不一致。而且点开这个文件下载SDK的时候，因为网络原因没办法下载。总之安装过程一言难尽。留一个百度网盘吧。</p>
<p>链接：<a href="https://pan.baidu.com/s/1y47h84sifc_xt6E0UtoVfA" target="_blank" rel="noopener">https://pan.baidu.com/s/1y47h84sifc_xt6E0UtoVfA</a><br>提取码：uokq </p>
<p>下载完成之后，解压，按照下图的方式填上地址。OK。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPackaging/2.jpg">
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/03/2019-06-03-UE4的热更新与HTTP（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/03/2019-06-03-UE4的热更新与HTTP（三）/" class="post-title-link" itemprop="url">UE4的热更新与HTTP（三）</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-03 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-03T00:00:00+08:00">2019-06-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-06 10:03:52" itemprop="dateModified" datetime="2019-06-06T10:03:52+08:00">2019-06-06</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章已经介绍完文件下载，为了测试代码功能，需要进行测试。这一篇文章就是来介绍如何搭建文件服务器，计算对应的Md5值并生成md5table.txt文件，以及记录测试过程中遇到的几个问题。</p>
<h2 id="搭建文件服务器"><a href="#搭建文件服务器" class="headerlink" title="搭建文件服务器"></a>搭建文件服务器</h2><p><a href="https://blog.csdn.net/zhangnana200/article/details/77116030" target="_blank" rel="noopener">https://blog.csdn.net/zhangnana200/article/details/77116030</a> 照着这个做基本OK 其中两个问题多解释一下</p>
<p>1、配置安装Apache的主服务的时候，出现的命令行 Error底下一行没有后续提示，说明本次运行没有发生错误。成功安装。不是说出现Error就是有错。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4HotUpdate&HTTP3/1.jpg">

<p>2 配置安装Apache的主服务的时候，用cmd命令行启动，可能会报错</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4HotUpdate&HTTP3/2.jpg">

<p>必须通过管理员身份启动，在这个目录下找到cmd.exe，用管理员身份启动</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4HotUpdate&HTTP3/3.jpg">



<h2 id="计算Md5值"><a href="#计算Md5值" class="headerlink" title="计算Md5值"></a>计算Md5值</h2><p>前文介绍过md5table.txt文件是用来保存资源信息的，每一行是 “FileName - Md5 - FileSize” 的形式。这里用Java实现。</p>
<pre><code>import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.security.MessageDigest;
import java.util.ArrayList;

public class Main {

    /**
     * FileServer底下的所有目录的所有文件全部收集起来。FileServer文件夹下的文件不包括在内
     */
    private static void GetAllFilesFromFolder(File folder, ArrayList&lt;File&gt; result, boolean bIncludeFile){
        for(File file : folder.listFiles()){
            if(file.isFile()){
                if(bIncludeFile){
                    result.add(file);
                }
            }
            if(file.isDirectory()){
                GetAllFilesFromFolder(file, result, true);
            }
        }
    }

    public static void main(String[] args) {
        String Path = &quot;G:\\FileServer&quot;;
        int PathLength = Path.length();
        File folder = new File(Path);

        ArrayList&lt;String&gt; output = new ArrayList&lt;&gt;();
        byte[] buffer = new byte[8192];
        ArrayList&lt;File&gt; result = new ArrayList&lt;&gt;();
        GetAllFilesFromFolder(folder, result, false);

        for(File file : result){
            try{
                FileInputStream stream = new FileInputStream(file);
                MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
                int length;
                while((length = stream.read(buffer)) != -1){
                    md.update(buffer, 0 , length);
                }
                stream.close();
                String relevantPath = file.getAbsolutePath().substring(PathLength + 1);
                String fileMd5 = HexBin.encode(md.digest());
                //文件大小不要超过2GB int32 hold不住
                String line = String.format(&quot;%s,%s,%s&quot;,relevantPath,fileMd5,file.length());
                output.add(line);
            }
            catch(Exception e){
                e.printStackTrace();
            }
        }
        File outputFile = new File(Path+&quot;\\android_resource_md5.txt&quot;);
        try{
            FileWriter outputFileWrite = new FileWriter(outputFile);
            StringBuffer sb = new StringBuffer();
            output.forEach(line-&gt;{
                String newLine = line.replaceAll(&quot;\\\\&quot;,&quot;/&quot;);
                sb.append(newLine);
                sb.append(&quot;\r\n&quot;);
            });
            outputFileWrite.write(sb.toString());
            outputFileWrite.close();
        }
        catch(Exception e){
            e.printStackTrace();
        }
    }
}</code></pre><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4HotUpdate&HTTP3/4.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4HotUpdate&HTTP3/5.jpg">

<p>这是我利用Apache搭建的文件服务器，和本地电脑对应的文件夹。上述Java代码会打包FileServer文件夹下的所有文件，但是不包括FileServer这一级文件夹下的文件。也就是两个txt文件不是打包的内容。执行代码就会把Contents Paks文件夹下的内容生成对应的md5table文件，以下是我的生成结果。</p>
<pre><code>Contents/98108100.png,C90B90492AF6F2F69E7AF2CC0B4956EB,166528
Contents/back10310.png,82E41BD48639DD803ED219AB268E72B7,344481
Contents/back10400.png,9357A844E29BDF7A44CA1F1F9E77F6A5,280861
Contents/back20151001.png,DF8C365A3BB27C848DFCDCE33CEFA28C,713083
Contents/back20151101.png,6C279F4A70CFFD7B561A34689E9E113C,706371
Contents/back20151102.png,BD432717CB5E455884F32334AAEFD920,618290
Contents/back20160901.png,01CC1E48F35C35968AD596F570CBA2B1,766562
Contents/back20503.png,F33275CDCC6419DAB977D5A581664439,699881
Contents/back20902.png,740A622EAF7B61D90238845032645FD4,662138
Contents/back21805.png,38119D16B52EE75C99BA857B68CC6727,805909
Contents/codeworks.json,F4C986505671BCE0816C6D64496EF4C7,149992
Contents/equip00002.png,09C797A31A8170D2856FA110E4BC80A4,248845
Contents/Ereshkigal_Stage1_Sheet.png,C9DF4725291069BFC2B24FEF6F238582,1145249
Contents/Ereshkigal_Stage2_Sheet.png,F40268EF1BD371B808C3F8F5A2C0C6CF,1255084
Contents/Ereshkigal_Stage3_Sheet.png,9301113E4B752B454602CF8B41959C75,1150685
Contents/Halal_eresh.png,C754266747231CE94AA6839E995DA795,927168
Contents/image.png,0FF7EF07F5219AF8F8714F023E99CD66,101881
Contents/ObjectCN.rar,B56D7E47A0A9A5172782A609BB21572C,127616
Paks/JetBrains.Rider-2018.1.pak,111FC7BBA27B081D2AE2C2AED6564EBD,294398520
Paks/UnrealEngine-release.pak,A207EA0643F428CCC06332F6E11FBC93,288092632</code></pre><h2 id="测试问题"><a href="#测试问题" class="headerlink" title="测试问题"></a>测试问题</h2><h4 id="0KB文件"><a href="#0KB文件" class="headerlink" title="0KB文件"></a>0KB文件</h4><p>在实际测试的过程中，发现了一个问题。当我在服务器上部署文件的时候，HTTP下载的过程中碰到那种 0KB 的文件，会直接报下载失败。因为我们已经在md5table.txt 记录了文件大小，所以我们可以在生成md5table.txt的过程中直接过滤掉 0KB 的文件，或者在启动HTTP下载的时候，遇到文件大小为0的文件直接在对应的位置生成一个文件。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>我实现的热更新管理器 UpdateResourceManager 是一个单例，模仿了 PlatformFileManager 的实现，头文件定义：</p>
<pre><code>class UpdateResourceManager{
public:
   //......
private:
   //......
public:
   static UpdateResourceManger&amp; Get(); 
}
UpdateResourceManager&amp; UpdateResourceManager::Get() {
    static UpdateResourceManager Singleton;
    return Singleton;
}
</code></pre><p>这样定义在VS中是不会报错的，但是在UE4中会报错，提示 error: lnk 2005 重复定义。重新看了 PlatformFileManager  的实现，它是把实现部分放到了 .cpp 文件里，转移这个Get函数后成功编译通过了。感觉很奇怪，UE4净整一些有的没的。报错如下：</p>
<p>UpdateResourceManager.cpp.obj : error LNK2005: “public: static class UpdateResourceManager &amp; __cdecl UpdateResourceManager::Get(void)” (?Get@UpdateResourceManager@@SAAEAV1@XZ) 已经在 MyActor.cpp.obj 中定义</p>
<h4 id="添加-h-cpp-文件"><a href="#添加-h-cpp-文件" class="headerlink" title="添加 .h .cpp 文件"></a>添加 .h .cpp 文件</h4><p>添加文件最好在UE4中新建，不要通过vs的项目列表 新建项，因为如果这样，写好了.h .cpp文件后，别的文件里include这个 .h文件是找不到的。#include “UpdateResourceManager” 会提示找不到这个文件。</p>
<h4 id="DownloadTask实例变量放在堆还是栈？"><a href="#DownloadTask实例变量放在堆还是栈？" class="headerlink" title="DownloadTask实例变量放在堆还是栈？"></a>DownloadTask实例变量放在堆还是栈？</h4><p>这是一段从下载列表里分离出pak下载任务 和 普通文件下载任务的过程。</p>
<pre><code>    for (int32 i = 0; i &lt; DownloadFileList.Num(); i++) {
        FString&amp; FileName = DownloadFileList[i];
        FString SavePath = Util::GetPersistentPath(FileName);
        //pak文件放到对应的TArray中，优先下载TaskArray，下载完毕后逐个下载Pak
        if (FileName.EndsWith(TEXT(&quot;.pak&quot;))) {
            FString PakFileName = FileName;
            if (PakFileName.Equals(BreakPointPakFileName)) {
                continue;
            }
            FString PakSavePath = SavePath;
            int32 PakFileSize = NewMd5Table.Find(FileName)-&gt;Size;
            FString PakMd5 = NewMd5Table.Find(FileName)-&gt;Md5;
            DownloadPakFileTask* temp = new DownloadPakFileTask(this, PakFileName, PakSavePath, PakFileSize, PakMd5);
            PakTaskArray.Add(temp);
            continue;
        }
        TaskArray.Add(DownloadTask(this, FileName, SavePath, ServerResVersion, NewMd5Table[FileName]));
    }</code></pre><p>看一下 DownloadPakFileTask 的构造函数</p>
<pre><code>class DownloadPakFileTask {
public:
    DownloadPakFileTask(UpdateResourceManager* InParent, FString&amp; InFileName, FString&amp; InSavePath, int32 FileSize, FString&amp; InMd5)
        : Parent(InParent), FileName(InFileName), SavePath(InSavePath), PakFileSize(FileSize), PakMd5(InMd5), bFinished(false), NextTaskIndex(0), SuccessfulPartialTaskCount(0), RunningHttpCount(0)
    {
        int32 TwentyMB = 20 * 1024 * 1024;
        int32 TaskCount = FMath::CeilToInt(FileSize * 1.0f / TwentyMB);
        for (int32 index = 0; index &lt; TaskCount; index++) {
            FString From = FString::FromInt(index * TwentyMB);
            FString To = FString::FromInt((index + 1) * TwentyMB - 1); //如果文件大小是 1500KB，那么第二个PartialTask是1024-2047.超出了文件的范围，不过从PC下载测试来看是没问题的。
            FString Range = FString::Format(TEXT(&quot;bytes={0}-{1}&quot;), { From, To });
            FString Suffix = FString::Format(TEXT(&quot;temp{0}&quot;), { index });
            FString TaskSavePath = FString::Format(TEXT(&quot;{0}/HotUpdateTemp/{1}{2}&quot;), { FPaths::ProjectPersistentDownloadDir(),  FileName, Suffix }); //  patchPak.paktemp1   patchPak.paktemp2
            //PartialTask Task = PartialTask(this, FileName, false, Range, TaskSavePath);
            PartialTasks.Add(new PartialTask(this, FileName, false, Range, TaskSavePath));
        }
    }
}</code></pre><p>这一段代码的结构是这样的，UpdateResourceManager是一个单例，持有</p>
<ul>
<li><code>TArray&lt;DownloadTask&gt;  TaskArray</code> </li>
<li><code>TArray&lt;DownloadPakFileTask&gt;  PakTaskArray</code>  </li>
</ul>
<p>两者分别用来存放除了pak外的普通文件的下载任务 和 pak文件下载任务。其中 DownloadPakFileTask 是分成很多个PartialTask 的。也就是结构是这样的 UpdateResourceManager -&gt; 持有多个DownloadPakFileTask  -&gt; 持有多个PartialTask。同时DownloadPakFileTask  也持有热更新管理器的指针，PartialTask也持有DownloadPakFileTask  的指针。它们是一个互相引用的结构。</p>
<p>注意 new DownloadPakFileTask 这一段代码，本来是这么实现的</p>
<pre><code>TArray&lt;DownloadPakFileTask&gt; PakTaskArray;
DownloadPakFileTask temp = DownloadPakFileTask(this, PakFileName, PakSavePath, PakFileSize, PakMd5);
PakTaskArray.Add(temp);</code></pre><p>DownloadPakFileTask 是在栈上的！在DownloadPakFileTask  的构造函数里，本来PartialTask也不是用new的方式，也是直接生成放在栈上的。</p>
<p>当我执行的时候发现DownloadPakFileTask生成的时候，每一个PartialTask还是可以通过指针看到DownloadPakFileTask底下的内容的。但是添加到TArray中后，只有PakFileTask指针正确 PakFileSize正确，其他的FString都显示为乱码了 </p>
<p>也就是说，试着把DownloadPakFileTask当做A，PartialTask当做B，两者互相引用。我们断点查看A的时候可以看到内容，但是通过A-&gt;B-&gt;A 这样看的时候就有一些内容是丢失的。非常令人疑惑的一点，指针一致，但是内容却丢失了一部分。在栈上生成对象然后添加到TArray中才会出现这种情况，这也导致了我后来发起http请求的失败。可能是栈容量的问题？或者TArray的内部实现的问题？详细原因仍然不清楚。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/02/2019-06-02-UE4的热更新与HTTP（一）/" class="post-title-link" itemprop="url">UE4的热更新与HTTP（一）</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-02T00:00:00+08:00">2019-06-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-03 20:46:59" itemprop="dateModified" datetime="2019-06-03T20:46:59+08:00">2019-06-03</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一系列的文章会探讨UE4热更新用HTTP的实现方案。首先第一篇文章先来讲讲UE4的HTTP。</p>
<h2 id="先来创建一条Http请求吧"><a href="#先来创建一条Http请求吧" class="headerlink" title="先来创建一条Http请求吧"></a>先来创建一条Http请求吧</h2><pre><code>void Download(const FString&amp; URL){
    //发送Http请求
    TSharedRef&lt;IHttpRequest&gt; HttpReuest = FHttpModule::Get().CreateRequest();
    HttpReuest-&gt;SetURL(URL);
    HttpReuest-&gt;SetVerb(TEXT(&quot;GET&quot;));
    HttpReuest-&gt;SetHeader(TEXT(&quot;Content-Type&quot;), TEXT(&quot;application/x-www-form-urlencoded&quot;));
    HttpReuest-&gt;OnProcessRequestComplete().BindRaw(this, &amp;FHttpRequestTest::OnRequestComplete);
    HttpReuest-&gt;OnRequestProgress().BindRaw(this, &amp;FHttpRequestTest::OnRequestProgress);
    HttpReuest-&gt;ProcessRequest();
    }
    //请求完成
    void OnRequestComplete(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded)
    {
    }
    //请求进度 每帧调用
    void OnRequestProgress(FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived)
    {
    }
</code></pre><p>这是一段Http的发送请求的代码，可以看到通过HttpModule创建了一个IHttpRequest的指针，并设置这个Http的相关属性，URL、Header等，绑定下载过程中每帧的回调函数和下载完成的回调函数。（UE4确实对HTTP方法的封装还是不错的，能够覆盖很多的应用场景。）</p>
<p>注意上面这段代码，不管是创建HttpRequest的过程，还是绑定的回调方法，全部都是在游戏主线程中执行的。</p>
<p>HttpRequest的ProcessRequest方法，作用是根据设置的URL、Header等等设置一些HttpRequest的具体属性，如果设置属性失败，那么会直接执行FinishedRequest执行绑定的回调方法，如果设置属性成功则将这条请求添加到Http线程的PendingThreadedRequests。</p>
<p>这里涉及到了多线程方面的处理，除了游戏的主线程外，负责HTTP处理的是HTTP线程。</p>
<p>HttpModule启动一个HttpManager，HttpManager持有一个HttpThread的指针。在初始化模块的时候，就已经生成了一个线程。它持有很多Request的TQueue线程安全的队列，例如PendingThreadedRequests就是待执行的HTTP请求。HttpThread线程有一个每帧的更新函数，从待处理的数组中取出请求去执行，正在执行的请求接收数据，下载完成的请求标记为成功。ProcessRequest方法就是把当前请求给放入Http线程的待执行Http队列中，也就是PendingThreadedRequests。在Http完成之后，被标记为成功，然后就会被加入CompletedThreadedRequests数组。在游戏主线程中，HttpManager的Tick函数中，就会取出这些已经完成的请求，并去执行它们的回调方法。</p>
<p>以下是HttpThread线程的持有队列。</p>
<pre><code>     /** 
     * Threaded requests that are waiting to be processed on the http thread.
     * Added to on (any) non-HTTP thread, processed then cleared on HTTP thread.
     */
    TQueue&lt;IHttpThreadedRequest*, EQueueMode::Mpsc&gt; PendingThreadedRequests;

    /**
     * Threaded requests that are waiting to be cancelled on the http thread.
     * Added to on (any) non-HTTP thread, processed then cleared on HTTP thread.
     */
    TQueue&lt;IHttpThreadedRequest*, EQueueMode::Mpsc&gt; CancelledThreadedRequests;

    /**
     * Currently running threaded requests (not in any of the other lists, except potentially CancelledThreadedRequests).
     * Only accessed on the HTTP thread.
     */
    TArray&lt;IHttpThreadedRequest*&gt; RunningThreadedRequests;

    /**
     * Threaded requests that have completed and are waiting for the game thread to process.
     * Added to on HTTP thread, processed then cleared on game thread (Single producer, single consumer)
     */
    TQueue&lt;IHttpThreadedRequest*, EQueueMode::Spsc&gt; CompletedThreadedRequests;

    /** Pointer to Runnable Thread */
    FRunnableThread* Thread;</code></pre><p>为了讲的清楚一些，举个例子：</p>
<p>假设有一家餐厅，前台有一个人负责帮客人点菜，上菜。后厨房也有一个人负责做菜，前台后台中间有四个列表。现在来了一个客人，点了一份宫保鸡丁，前台并不是直接喊厨师说给做一份菜，而是写好菜的标签，然后放到待处理的列表中，然后就不管了。后台的厨师看到这里待处理列表新增了一份菜的标签，就开始做这道菜。做菜的过程中，就把待处理列表的标签给划掉，并且在“正在做菜”的列表中加上宫保鸡丁标签。做完宫保鸡丁后把菜的标签放到“已经做好的菜”的列表，并且把菜放上。这个时候前台看到了这份菜已经做好了，就端去给客人。如果中间发生了意外，比如后厨房里已经没有鸡肉了做不了宫保鸡丁，或者客人突然要取消，那么厨师或者前台就把菜标签挂到取消列表中。前台随后再把菜标签放到“已经做好的菜”的列表，但是这个时候并没有放上做好的菜。也就是这次做菜失败了。</p>
<p>把以上场景带入到HTTP请求以及回复是差不多的。两个人、两个线程是两条并行的线，各自忙各自的事。客人点菜就相当于一个HTTP请求，前台（游戏主线程）只是把请求放到待做列表中而已，等厨师做完菜（HTTP线程请求完数据）就把菜放到完成列表里，前台看到菜做好了就把菜端给客人（主线程取出完成列表的请求，执行回调）。而中间的四个列表，就是对应代码中的四个TQueue线程安全的队列。</p>
<h2 id="Http模块结构"><a href="#Http模块结构" class="headerlink" title="Http模块结构"></a>Http模块结构</h2><p>UE4的HTTP代码部分主要可以分为四个部分，HttpModule，HttpManager，HttpThread，HttpRequest。</p>
<ul>
<li><p>Module：UE4的许多功能模块是以Module为划分的，HttpModule可以说是Http模块的“老大”。HttpModule负责初始化模块的一些配置，创建一个HttpManager并初始化，还有提供一个创建Http请求的通用方法CreateRequest。</p>
</li>
<li><p>HttpManager：FHttpManager定义了具体的操作流程。UE4调用外部库Curl来做Http请求。FCurlHttpManager继承自FHttpManager，对一些虚方法提供了Curl的具体实现。</p>
</li>
<li><p>HttpThread：FCurlHttpThread也是继承自FHttpManger</p>
</li>
<li><p>HttpRequest：只能通过Module里提供的方法来创建一个Http请求，这个请求继承了IHttpRequest。具体实现是CurlHttpRequest。IHttpRequest只有少量的接口，如设置URL、设置头等。细节由CurlHttpRequest实现。</p>
</li>
</ul>
<p>UE4将流程定义在FHttpManger和FHttpThread里，然后具体实现FCurlHttpManager、FCurlHttpThread里结合外部库Curl来实现。如果以后出了什么更高效的Http外部库，那也只需要修改具体的实现部分，流程方面是不用改动的。这种思想也是值得学习的。根据“我”想对外提供的方法api等定制一套流程，具体实现由子类去完成。相当于做了一层封装。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>CurlHttpThread里有一个Tick函数，这个函数实现了单线程、高并发、非阻塞的去执行HTTP任务。代码摘录如下，具体细节可以直接网上搜索Curl单线程、高并发等关键字。</p>
<pre><code>void FCurlHttpThread::HttpThreadTick(float DeltaSeconds)
{
    QUICK_SCOPE_CYCLE_COUNTER(STAT_FCurlHttpThread_HttpThreadTick);
    check(FCurlHttpManager::GMultiHandle);

    const int NumRequestsToTick = RunningThreadedRequests.Num();

    {
        if (RunningThreadedRequests.Num() &gt; 0)
        {
            int RunningRequests = -1;
            {
                QUICK_SCOPE_CYCLE_COUNTER(STAT_FCurlHttpThread_HttpThreadTick_Perform);
                curl_multi_perform(FCurlHttpManager::GMultiHandle, &amp;RunningRequests);
            }

            // read more info if number of requests changed or if there&#39;s zero running
            // (note that some requests might have never be &quot;running&quot; from libcurl&#39;s point of view)
            if (RunningRequests == 0 || RunningRequests != RunningThreadedRequests.Num())
            {
                for (;;)
                {
                    QUICK_SCOPE_CYCLE_COUNTER(STAT_FCurlHttpThread_HttpThreadTick_Loop);
                    int MsgsStillInQueue = 0;    // may use that to impose some upper limit we may spend in that loop
                    CURLMsg * Message = curl_multi_info_read(FCurlHttpManager::GMultiHandle, &amp;MsgsStillInQueue);

                    if (Message == NULL)
                    {
                        break;
                    }

                    // find out which requests have completed
                    if (Message-&gt;msg == CURLMSG_DONE)
                    {
                        CURL* CompletedHandle = Message-&gt;easy_handle;
                        curl_multi_remove_handle(FCurlHttpManager::GMultiHandle, CompletedHandle);

                        IHttpThreadedRequest** Request = HandlesToRequests.Find(CompletedHandle);
                        if (Request)
                        {
                            FCurlHttpRequest* CurlRequest = static_cast&lt; FCurlHttpRequest* &gt;(*Request);
                            CurlRequest-&gt;MarkAsCompleted(Message-&gt;data.result);

                            UE_LOG(LogHttp, Verbose, TEXT(&quot;Request %p (easy handle:%p) has completed (code:%d) and has been marked as such&quot;), CurlRequest, CompletedHandle, (int32)Message-&gt;data.result);

                            HandlesToRequests.Remove(CompletedHandle);
                        }
                        else
                        {
                            UE_LOG(LogHttp, Warning, TEXT(&quot;Could not find mapping for completed request (easy handle: %p)&quot;), CompletedHandle);
                        }
                    }
                }
            }
        }
    }

    FHttpThread::HttpThreadTick(DeltaSeconds);
}</code></pre>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/02/2019-06-02-UE4的热更新与HTTP（二）/" class="post-title-link" itemprop="url">UE4的热更新与HTTP（二）</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-02T00:00:00+08:00">2019-06-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-05 20:43:32" itemprop="dateModified" datetime="2019-06-05T20:43:32+08:00">2019-06-05</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章讲了UE4源码里Http的部分内容，创建一条http请求，Http模块的结构。</p>
<p>这一篇内容来讲讲我在实现UE4的热更新中遇到的一些困难以及如何用UE4的Http来完成断点续传功能。</p>
<h2 id="UE4热更新的思路"><a href="#UE4热更新的思路" class="headerlink" title="UE4热更新的思路"></a>UE4热更新的思路</h2><p>热更新的整体思路是这样的，文件服务器与本地都会有一个版本文件，姑且分别叫做ServerResVersion.txt和LocalResVersion.txt。也都会有一个存储资源信息的Md5文件，这个文件有多行，每一行的格式是“FileName-Md5-FileSize”，其中Md5值是用来保证下载的文件一致的。首先本地启动之后启动http请求加载服务器版本文件，加载完毕后加载本地版本文件，存储为int32 ServerResVersion 和 int32 LocalResVersion，比较版本是否有差异。随后加载本地Md5文件，存储到TMap&lt;FString, FileInfo&gt; LocalMd5，检查每一个资源名字是否在本地有对应的资源，也就是检查资源的完整性，如果资源完整且版本没有差异，那么此时就可以进入游戏了。如果有丢失文件，那么必须移除LocalMd5中对应的数据。也就是要保证LocalMd5存储的是本地存在的资源信息。</p>
<p>如果资源是资源不是完整的，或者版本有更新，那么这个时候就要去加载服务器的Md5文件。知道本地资源列表LocalMd5与服务器资源列表ServerMd5之后，删除本地的无用文件，并且整理出一份下载文件列表去服务器加载新的或者丢失的资源文件。</p>
<p>删除本地的无用文件，可以通过遍历LocalMd5，如果ServerMd5不存在就说明在新版本中这个资源已经被删除了。整理下载文件列表，可以通过遍历ServerMd5，如果新版本存在的而本地不存在，那么就说明这个资源要么是资源丢失，要么是新更新的资源。</p>
<p>整理出一份下载文件列表之后，就当做 TArray<fstring> DownloadList 吧，FString 存储的是这个资源的名字。根据自己的文件服务器host 等生成URL，生成HTTP去请求数据。</fstring></p>
<p>为了确保下载的是正确内容，还可以在下载完后，对下载的数据在本地计算生成一个ComputedMd5，并且和ServerMd5的值比较一次，如果正确就说明下载的文件是正确的。</p>
<h2 id="UE4的HTTP的局限"><a href="#UE4的HTTP的局限" class="headerlink" title="UE4的HTTP的局限"></a>UE4的HTTP的局限</h2><p>在有了热更新的思路之后，我们需要考虑如何实现具体的功能。UE4对HTTP做了一层封装，它是引用的外部库libcurl来做的底层，实现了单线程高并发，在上一篇文章中已经提过。使用这个库的例子在官网或者一些其他人分享的文章里都有很多，推荐找一找类似的文章了解一下。像后文会讲到的断点续传功能，这个库就有一个ResumeFrom的功能可以实现</p>
<p><code>curl_easy_setopt(handle, CURLOPT_RESUME_FROM, localFileLenth);  *// 从本地大小位置进行请求数据*</code></p>
<p>具体可以参考这一篇文章《coco2dx c++ 断点续传实现》 <a href="https://blog.csdn.net/vpingchangxin/article/details/22309067" target="_blank" rel="noopener">https://blog.csdn.net/vpingchangxin/article/details/22309067</a></p>
<p>虽然这个库的功能挺多，但是UE4提供的接口却不是很多。这些接口封装得很好，但是与之相对的，实现的功能就不容易拓展，尤其是在不改变源码的情况下。先来看看HTTP我们常用的函数：</p>
<ol>
<li>创建HTTP请求</li>
<li>设置URL、Header、Verb</li>
<li>每帧回调函数，完成回调函数</li>
</ol>
<p>对于下载小文件来说，这真的是非常方便。只需要设置URL等一些基础属性，即可下载。但是复杂的功能，比如断点续传功能，像上面的ResumeFrom的代码，源码外部是无法这么写的。总而言之就是热更新的时候，还需要对这些HTTP做一些改造才行。</p>
<p>接下来将结合之前的思路来实现热更新功能。</p>
<h2 id="下载多个小文件"><a href="#下载多个小文件" class="headerlink" title="下载多个小文件"></a>下载多个小文件</h2><p>结合热更新的思路和HTTP接口的局限，下面来实现下载多个小文件的功能。这里直接从得到文件下载列表之后接着讲，因为之前的步骤，按照思路来还是比较容易实现的。</p>
<p>对 TArray<fstring> DownloadList 来说，每一个FString 即 FileName即代表依次HTTP下载，对每一个HTTP下载封装为DownloadTask。所有下载任务保存在 TArray<downloadtask> TaskArray 中。</downloadtask></fstring></p>
<p>UpdateResourceManager 管理器启动五个下载任务，也就是提交五个HTTP请求，如果其中一个下载完成了，那么如果还有后续下载任务，继续从TaskArray中取出任务，并执行。UpdateResourceManager中还有 int32 RunningTaskNum（正在执行的HTTP请求的数量）和 int32 SuccessfulDownloadTaskNum（已经完成的请求）。</p>
<pre><code>void UpdateResourceManager::BeginDownloadResource() {
    CurHostIndex = 0;
    if (TaskArray.Num() &gt; 0) {
        RunningTaskNum = 0;
        int32 ConcurrentTaskCount = FMath::Min(TaskArray.Num(), 5); //有五个任务以上时，最多同时执行五个任务
        for (int32 i = 0; i &lt; ConcurrentTaskCount; i++) {
            DownloadTask&amp; Task = TaskArray[i];
            TryDownloadTask();
        }
    }
}</code></pre><pre><code>void UpdateResourceManager::TryDownloadTask() {
    DownloadTask*  NextDownloadTask = nullptr;
    for (int32 i = NextDownloadTaskIndex; i &lt; TaskArray.Num() || CurHostIndex &lt; hosts.Num(); i++) {
        if (i == TaskArray.Num()) {
            i = 0;
            CurHostIndex++;
            if (CurHostIndex == hosts.Num()) {
                UE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, all hosts try&quot;), CurHostIndex - 1);
                break;
            }
            else {
                UE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, CurHostIndex%d start&quot;), CurHostIndex - 1, CurHostIndex);
            }
        }
        if (TaskArray[i].bFinished == false &amp;&amp; TaskArray[i].IsRunning == false) {
            NextDownloadTask = &amp;TaskArray[i];
            NextDownloadTaskIndex = i + 1;
            break;
        }
    }

    if (NextDownloadTask == nullptr) {
        //执行TryDownload说明还有任务下载，却取不到任务说明已经尝试了hosts.Num()次下载，可能是由与网络原因失败了。
        UE_LOG(LogTemp, Warning, TEXT(&quot;network doesn&#39;t work, still have DownloadTask to do.&quot;));
        return;
    }
    RunningTaskNum++;
    NextDownloadTask-&gt;SendHttpRequest();
}</code></pre><pre><code>void UpdateResourceManager::FinishOneTask(FString&amp; FileName) {
    RunningTaskNum--;
    UE_LOG(LogTemp, Warning, TEXT(&quot;RunningTaskNum=%d, SuccessfulDownloadTaskNum=%d&quot;), RunningTaskNum, SuccessfulDownloadTaskNum);
    //一个下载任务完成 通知界面更新进度
    UpdateDownloadProgress();

    //完成下载任务，去下载PAk文件
    if (RunningTaskNum == 0 &amp;&amp; SuccessfulDownloadTaskNum == TaskArray.Num()) {
        CurrentUpdateState = EUpdateState_UpdateResourceFinished;
        UpdateStateChange();
    }
    else if (RunningTaskNum + SuccessfulDownloadTaskNum == TaskArray.Num()) {
        UE_LOG(LogTemp, Warning, TEXT(&quot;waiting left DownloadTask to finish&quot;)); //应该要出现四次！
        return;
    }
    else {
        //还有任务没有下载完成。
        TryDownloadTask();
    }
}</code></pre><p>每次完成一个下载任务，那么检查，是否当前还有正在进行的下载任务，如果为0，且成功下载的个数等于TaskArray.Num()， 说明下载已经完成。如果剩余的下载任务与已经完成的任务的和等于TaskArray.Num()，说明不需要再去尝试下载了。</p>
<p>DownloadTask定义如下：</p>
<pre><code>class DownloadTask {
private:
    UpdateResourceManager* Parent;
    FString FileName; //下载文件名字
    FString SavePath;   //下载完成后存放的位置
    int32 ServerResVersion; //组装URL
    FString Md5;      //组装URL

public:
    DownloadTask(UpdateResourceManager* InParent, FString&amp; InFileName, FString&amp; InSavePath, int32 InServerResVersion, FileInfo&amp; InFileInfo)
        : Parent(InParent), FileName(InFileName), SavePath(InSavePath), ServerResVersion(InServerResVersion), Md5(InFileInfo.Md5), FileSize(InFileInfo.Size), bFinished(false), IsRunning(false){

    };
    //FString FileName; //下载文件名字
    int32 FileSize;
    bool bFinished;
    bool IsRunning;
    void SendHttpRequest();
};</code></pre><p>其中 bFinished 为这个任务是否完成，IsRunning表明这个任务是否正在运行。TaskArray是由 UpdateResourceManager 持有的，每个DownloadTask 也会有这个热更新管理器的指针 Parent。 SendHttpRequest 如下</p>
<pre><code>void DownloadTask::SendHttpRequest() {
    FString URL = Parent-&gt;GetResURL(FileName, Md5);
    TSharedRef&lt;IHttpRequest&gt; HttpRequest = FHttpModule::Get().CreateRequest();
    HttpRequest-&gt;SetURL(URL);
    HttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));
    HttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) {
        // 完成回调
    });
    HttpRequest-&gt;OnRequestProgress().BindLambda([&amp;](FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) {
        // 处理过程回调
    });
    UE_LOG(LogTemp, Warning, TEXT(&quot;DownloadTask  fileURL is (%s)&quot;), *URL);
    HttpRequest-&gt;ProcessRequest();
}</code></pre><p>其中完成回调：</p>
<pre><code>HttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) {
        if (bSucceeded &amp;&amp; HttpResponse.IsValid() &amp;&amp; HttpResponse-&gt;GetContentLength() &gt; 0) {
            if (IFileManager::Get().FileExists(*SavePath)) {
                IFileManager::Get().Delete(*SavePath);
            }
            TArray&lt;uint8&gt; BinaryFileContent = HttpResponse-&gt;GetContent();
            FFileHelper::SaveArrayToFile(BinaryFileContent, *SavePath);

            //MD5算法
            //FString ComputedMd5 = Util::ComputeMd5();
            uint8 Digest[16];
            FMD5 FileHasher;
            FileHasher.Update(BinaryFileContent.GetData(), BinaryFileContent.Num());
            FileHasher.Final(Digest);
            FString ComputedMd5;
            for (int32 i = 0; i &lt; 16; i++) {
                ComputedMd5 += FString::Printf(TEXT(&quot;%02x&quot;), Digest[i]);
            }
            //End

            if (ComputedMd5.Equals(Md5, ESearchCase::IgnoreCase)) {
                Parent-&gt;ResourceHasUpdate.Add(FileName);
                Parent-&gt;AppendMd5File(FileName, Md5, FileSize);
                Parent-&gt;AppendHasUpdateFile(FileName);
                bFinished = true;
                Parent-&gt;SuccessfulDownloadTaskNum++;
                Parent-&gt;FinishOneTask(FileName);
                return;
            }
            UE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&#39;t be here!! Download finish but md5 doesnt match&quot;));
            Parent-&gt;FinishOneTask(FileName);
        }
        else {
            FString URL = Parent-&gt;GetResURL(FileName, Md5);
            UE_LOG(LogTemp, Warning, TEXT(&quot;DownloadTask fail... ... fileURL is (%s)&quot;), *URL);
            Parent-&gt;FinishOneTask(FileName);
        }
    });</code></pre><p>如果请求失败则通知Parent 完成了一个任务，即使他失败了。</p>
<p>如果成功，则将这个文件保存到SavePath的位置，同时计算这个文件的Md5值，是否与ServerMd5值相同。如果相同那么可以确定这是一个完成的任务，把bFinished标记为成功，通知Parent。</p>
<p>以上是UpdateResourceManager 和 DownloadTask 的主要代码。libcurl内部实现是可以同时执行多个HTTP请求的，但是这样每个请求的速度就会相对的下降，如果执行完一个请求再执行下一个那也太慢了。因此我们让同时执行五个HTTP请求，每一个请求执行完毕后都会执行 FinishOneTask 验证是否需要继续申请任务执行。<strong>只有还有任务待执行，那么才会执行 TryDownload 的方法。</strong></p>
<p>为什么还要设置一个 CurHostIndex 呢？在手机平台的时候，经常会有网络波动的情况。假设有可能任务20失败了，这个时候后续的任务都完成了，那么就说明还有任务需要执行，还会执行到 TryDownload 的方法。这个时候，NextTaskIndex 已经执行到末尾，让它重新归0，重新遍历，开始判断，是否这个下载任务没有完成且没有正在执行，如果是那么它就是下一个下载任务。请求失败的原因也有可能是文件服务器的不稳定，因此会部署多个文件服务器，当第一次遍历存在失败任务的时候，下一轮遍历，就去尝试第二个文件服务器的地址。</p>
<p>上面我们讲了下载多个小文件的处理办法，基本上也是对UE4提供的HTTP接口做了一点封装：</p>
<ul>
<li>每一个请求封装成一个DownloadTask，记录下载状态。</li>
<li>同时执行多个下载任务，保证速度。</li>
<li>有几个host地址，那么就最多执行多少次遍历TaskArray，避免一些网络波动的情况。</li>
</ul>
<p>如果是Unity打包的话，这套打包机制简直为了它量身定制的，因为每个资源都是一个个独立的Bundle，那么只需要直接去下载就好了，下载失败，即使丢失数据，每一个Bundle的下载量也不大，只需要重新下载即可。但是UE4的话，热更新的文件列表里往往有一个pak的补丁包文件。这个补丁包集合了许多资源往往文件大小比较大。对手机平台来说，网络波动是很正常的事情，如果不小心网络中断，或者其他突发情况导致HTTP请求失败，那么这就意味着之前下载的数据全部消失。为了拯救它，我们需要在UE4的HTTP的基础上实现断点续传功能。</p>
<h2 id="下载单个大文件（断点续传）"><a href="#下载单个大文件（断点续传）" class="headerlink" title="下载单个大文件（断点续传）"></a>下载单个大文件（断点续传）</h2><p>正如我们之前所说，虽然libcurl库提供了ResumeFrom功能做，支持断点续传，但是我们在不改变源码的情况下是无法使用的。因此我们需要自己实现一套断点续传。</p>
<p>断点续传意味着，如果断开了连接，那么下次下载的时候是能够恢复进度继续执行的。思路是在HTTP下载数据的过程中就要把数据给保存在本地。那么来看看UE4提供的两个回调，每帧调用的回调只能知道下载进度，并不知道实际下载的内容。HTTP完成的回调，是可以取得HttpResponse的，但是比如网络突然中断的情况下，这个时候UE4的HTTP会被标记为完成，并且执行FinishedRequest，这个函数有两个分支，成功的话，就正常执行回调函数等等。失败的话会把HttpResonse设置为NULL，然后再执行回调函数。也就是说HTTP完成的回调有两种状态，成功的话能取到数据，失败的话是取不到已经下载的数据，也就无法把已经下载的数据给缓存下来。</p>
<p><code>void OnRequestComplete(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded){}</code></p>
<p>这么一看这种传输方式果然还是适合小文件。因为即使小文件失败了，那么直接重新下载就好了，如果失败了，那也就损失一点点流量。根本无所谓。但是如果是100、200M的文件，下载到最后突然一卡，尤其是手机平台更容易发生网络波动的情况，导致HTTP意外失败，这个时候如果必须全盘重新下载是非常糟心的体验。</p>
<p>实现断点续传的方法是用HTTP的Range头来实现断点续传，把一个大文件拆分成很多个下载任务来下载，每个HTTP只下载文件的一部分。下载完成的时候，把这些零散的文件给拼接起来。重新组成一个完整的文件。既然要把文件分成多个HTTP分段下载，那么我们需要知道这个文件具体的大小，假设一个下载任务只有10M，只有知道文件的大小才知道能分多少个下载任务。</p>
<p>分段下载的示例如下，如果下载范围是 0-499，那么总共是下载500个字节的数据，下一个下载范围就应该是500-999。</p>
<pre><code>    FString Range = TEXT(&quot;bytes=500-999&quot;)
    HttpRequest-&gt;SetHeader(TEXT(&quot;Range&quot;), Range);</code></pre><p>（更多的HTTP Header参考：<a href="https://kb.cnblogs.com/page/92320/）" target="_blank" rel="noopener">https://kb.cnblogs.com/page/92320/）</a></p>
<p>其中下载大文件，对于UE4来说主要是下载pak文件，类定义如下</p>
<pre><code>//下载pak文件
class DownloadPakFileTask {
public:
    DownloadPakFileTask(UpdateResourceManager* InParent, FString&amp; InFileName, FString&amp; InSavePath, int32 FileSize, FString&amp; InMd5)
        : Parent(InParent), FileName(InFileName), SavePath(InSavePath), PakFileSize(FileSize), PakMd5(InMd5), bFinished(false), NextTaskIndex(0), SuccessfulPartialTaskCount(0), RunningHttpCount(0)
    {
        int32 TwentyMB = 20 * 1024 * 1024;
        int32 TaskCount = FMath::CeilToInt(FileSize * 1.0f / TwentyMB);
        for (int32 index = 0; index &lt; TaskCount; index++) {
            FString From = FString::FromInt(index * TwentyMB);
            FString To = FString::FromInt((index + 1) * TwentyMB - 1); //如果文件大小是 1500KB，那么第二个PartialTask是1024-2047.超出了文件的范围，不过从PC下载测试来看是没问题的。
            FString Range = FString::Format(TEXT(&quot;bytes={0}-{1}&quot;), { From, To });
            FString Suffix = FString::Format(TEXT(&quot;temp{0}&quot;), { index });
            FString CleanFileName = FPaths::GetCleanFilename(FileName); //去掉Paks/
            FString TaskSavePath = FString::Format(TEXT(&quot;{0}/HotUpdateTemp/{1}{2}&quot;), { FPaths::ProjectPersistentDownloadDir(),  CleanFileName, Suffix }); //  patchPak.paktemp1   patchPak.paktemp2
            //PartialTask Task = PartialTask(this, FileName, false, Range, TaskSavePath);
            PartialTasks.Add(new PartialTask(this, FileName, false, Range, TaskSavePath));
        }
    }

    //上次http没有完全下载，记录下上次下载的内容。没有完全下载可能是因为http失败，也有可能是正常的发生意外。
    DownloadPakFileTask(UpdateResourceManager* InParent, TArray&lt;FString&gt;&amp; DownloadRecords,FString&amp; PakFileName, FString&amp; InSavePath, int32 FileSize, FString&amp; InMd5)
        : Parent(InParent),FileName(PakFileName), SavePath(InSavePath), PakFileSize(FileSize), PakMd5(InMd5), bFinished(false), NextTaskIndex(-1), SuccessfulPartialTaskCount(0), RunningHttpCount(0)
    {
        int32 TwentyMB = 20 * 1024 * 1024;
        for (int32 i = 4; i &lt; DownloadRecords.Num(); i++) {
            FString&amp; Line = DownloadRecords[i];
            int32 index = i - 4; //第5行开始是版本. index是下载任务对应的索引、后缀
            TArray&lt;FString&gt; temp1;// FileName,bSucceed,URL,,,,,
            Line.ParseIntoArray(temp1, TEXT(&quot;,&quot;), true);
            FString&amp; FileName = temp1[0];
            FString&amp; Range = temp1[2];
            FString&amp; SavePath = temp1[3];
            if (temp1[1] == TEXT(&quot;1&quot;)) { // 1表示下载完成，0表示尚未下载或者上次下载失败。
                PartialTasks.Add(new PartialTask(this, FileName, true, Range, SavePath));
                UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask%d has finished&quot;), index);
                SuccessfulPartialTaskCount++;
            }
            else {
                PartialTasks.Add(new PartialTask(this, FileName, false, Range, SavePath));
                UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask%d need download&quot;), index);
            }
        }
        for (int32 i = 0; i &lt; PartialTasks.Num(); i++) {
            PartialTask* Task = PartialTasks[i];
            if (Task-&gt;bFinished == false) {
                NextTaskIndex = i;
                break;
            }
        }
    }

    UpdateResourceManager* Parent;
    FString FileName;
    FString SavePath;
    int32 PakFileSize;
    FString PakMd5;
    bool bFinished;

    TArray&lt;PartialTask*&gt; PartialTasks;
    int32 NextTaskIndex; //下一个执行任务的索引;
    int32 SuccessfulPartialTaskCount;
    void SendHttps();
    void FinishOnePartialTask();

    int32 RunningHttpCount; //当前有多少个HTTP正在请求数据
};</code></pre><p>DownloadPakFileTask 的 FinishOnePartialTask如下</p>
<pre><code>void DownloadPakFileTask::FinishOnePartialTask() {
    RunningHttpCount--;
    UE_LOG(LogTemp, Warning, TEXT(&quot;RunningHttpCount:%d, SuccessfulPartialTaskCount:%d&quot;), RunningHttpCount, SuccessfulPartialTaskCount); //应该要出现四次！
    Parent-&gt;UpdateDownloadProgress();
    if (RunningHttpCount == 0 &amp;&amp; SuccessfulPartialTaskCount == PartialTasks.Num()) {
        //完成全部下载任务开始拼接
        FArchive* FileWriter = IFileManager::Get().CreateFileWriter(*SavePath);
        for (int32 index = 0; index &lt; PartialTasks.Num(); index++) {
            if (Parent-&gt;bTest) {
                FString log = FString::Format(TEXT(&quot;LoadFile:{0}&quot;), { PartialTasks[index]-&gt;SavePath });
                GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);
                UE_LOG(LogTemp, Warning, TEXT(&quot;LoadFile:%s&quot;), *(PartialTasks[index]-&gt;SavePath)); 
            }
            TArray&lt;uint8&gt; Buffer;
            FFileHelper::LoadFileToArray(Buffer, *(PartialTasks[index]-&gt;SavePath));
            FileWriter-&gt;Serialize(Buffer.GetData(), Buffer.Num());
        }
        FileWriter-&gt;Close();
        delete FileWriter;
        //拼接完成 删除临时文件
        IFileManager::Get().DeleteDirectory(*Parent-&gt;BreakPointDirectory, false, true);
        IFileManager::Get().Delete(*Parent-&gt;BreakPointInfoFilePath);
        IFileManager::Get().Delete(*Parent-&gt;BreakPointVersionFilePath);

        //Pak Md5
        TArray&lt;uint8&gt; PakContent;
        FFileHelper::LoadFileToArray(PakContent, *SavePath);
        uint8 Digest[16];
        FMD5 FileHasher;
        FileHasher.Update(PakContent.GetData(), PakContent.Num());
        FileHasher.Final(Digest);
        FString ComputedPakMd5;
        for (int32 i = 0; i &lt; 16; i++) {
            ComputedPakMd5 += FString::Printf(TEXT(&quot;%02x&quot;), Digest[i]); // 02表明如果结果为一位，则高位补充0， x 表明是结果16进制输出，
        }
        UE_LOG(LogTemp, Warning, TEXT(&quot;ComputedPakMd5:%s&quot;), *ComputedPakMd5);
        if (!PakMd5.Equals(ComputedPakMd5, ESearchCase::IgnoreCase)) {
            UE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&#39;t be here!! DownloadPak finish but md5 doesnt match. exit&quot;));
            return;
        }
        bFinished = true;
        Parent-&gt;ResourceHasUpdate.Add(FileName);
        Parent-&gt;AppendMd5File(FileName, PakMd5, PakFileSize);
        Parent-&gt;AppendHasUpdateFile(FileName);

        if (Parent-&gt;bTest) {
            UE_LOG(LogTemp, Warning, TEXT(&quot;pakfile finish:%s&quot;), *FileName);
            FString log = FString::Format(TEXT(&quot;pakfile finish:{0}&quot;), { FileName });
            GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);
        }

        Parent-&gt;CurrentUpdateState = EUpdateState_UpdatePakFile;
        Parent-&gt;UpdateStateChange();

    }
    else if ((RunningHttpCount + SuccessfulPartialTaskCount) == PartialTasks.Num()) {
        UE_LOG(LogTemp, Warning, TEXT(&quot;waiting left PartialTask to finish&quot;)); //应该要出现四次！
        return;
    }
    else {
        //还有http任务需要执行
        SendHttps();
    }
}</code></pre><p>DownloadPakFileTask 的 SendHttps 如下</p>
<pre><code>void DownloadPakFileTask::SendHttps() {
    //找到下一个HTTP任务
    PartialTask* NextTask = nullptr;
    for (int32 i = NextTaskIndex; i &lt; PartialTasks.Num() || Parent-&gt;CurHostIndex &lt; Parent-&gt;hosts.Num(); i++) {
        //遍历一次PartialTasks为一轮，在当前这一轮中，如果已经遍历结束，那么转到下一轮，查询是否有需要下载的任务（可能有因为网络波动而终止的HTTP，这些任务在下一轮中执行）
        if (i == PartialTasks.Num()) {
            i = 0;
            Parent-&gt;CurHostIndex++;
            if (Parent-&gt;CurHostIndex == Parent-&gt;hosts.Num()) {
                UE_LOG(LogTemp, Warning, TEXT(&quot;try all host, but still have PartialTask to finish&quot;));
                break;
            }
            else {
                UE_LOG(LogTemp, Warning, TEXT(&quot;CurHostIndex%d over, CurHostIndex%d start&quot;), Parent-&gt;CurHostIndex - 1, Parent-&gt;CurHostIndex);
            }
        }

        if (PartialTasks[i]-&gt;bFinished == false &amp;&amp; PartialTasks[i]-&gt;IsRunning == false) {
            NextTask = PartialTasks[i];
            NextTaskIndex = i + 1;
            break;
        }
    }
    //在进行了多轮的执行任务，如果取不到下一个HTTP任务，也可能是由于网络问题，虽然仍然有任务没有完成，但是遍历次数已经达到，不在遍历去取任务。保存断点信息。
    if (NextTask == nullptr) {
        bool bAllTaskFinished = true;
        for (int32 i = 0; i &lt; PartialTasks.Num(); i++) {
            if (PartialTasks[i]-&gt;bFinished == false) {
                bAllTaskFinished = false;
            }
        }
        if (bAllTaskFinished == false) {
            if (RunningHttpCount != 0) { // 网络中断。最后一条请求失败后保存信息，避免重复保存
                return;
            }
            if (Parent-&gt;bTest) {
                UE_LOG(LogTemp, Warning, TEXT(&quot;network doesn&#39;t work, still have partialtask to do. save info to local&quot;));
                FString log = TEXT(&quot;network doesn&#39;t work, still have partialtask to do. save info to local&quot;);
                GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);
            }
            //网络原因没有全部下载，记录本次下载的版本、所有的任务及完成情况，下次启动如果还是在更新这个版本，那么断点续传，取得这个保存的txt用来恢复信息并且继续下载
            TArray&lt;FString&gt; VersionTxt;
            FString VersionInfo = FString::FromInt(Parent-&gt;ServerResVersion); //保存正在热更新中的服务器版本，下次更新如果还是这个版本就可以断点续传，如果是新版本就要把这些记录文件删掉
            VersionTxt.Add(VersionInfo);
            VersionTxt.Add(FileName);
            FFileHelper::SaveStringArrayToFile(VersionTxt, *Parent-&gt;BreakPointVersionFilePath);
            TArray&lt;FString&gt; Info;
            Info.Add(FileName);
            Info.Add(SavePath);
            Info.Add(FString::FromInt(PakFileSize));
            Info.Add(PakMd5);
            for (int32 i = 0; i &lt; PartialTasks.Num(); i++) {
                PartialTask* Task = PartialTasks[i];
                FString bFinished = Task-&gt;bFinished ? TEXT(&quot;1&quot;) : TEXT(&quot;0&quot;);
                FString TaskInfo = FString::Format(TEXT(&quot;{0},{1},{2},{3}&quot;), { Task-&gt;FileName, bFinished, Task-&gt;Range, Task-&gt;SavePath });
                Info.Add(TaskInfo);
            }
            FFileHelper::SaveStringArrayToFile(Info, *Parent-&gt;BreakPointInfoFilePath);
        }
        else {
            UE_LOG(LogTemp, Warning, TEXT(&quot;Shouldn&#39;t be here&quot;));
        }
        return;
    }
    RunningHttpCount++;
    NextTask-&gt;SendPartialTaskHttp();
}</code></pre><p>对于下载大文件DownloadPakFileTask来说，有两种生成对象的方式，第一种传入FileName 和 FileSize等，根据FileSize计算出有多少个PartialTask。另一种是根据 TArray<fstring> 的方式来生成对象，这种方式是为了断点续传设计的。如果上次下载失败了，那么就记录DownloadPakFileTask 和 PartialTask 的信息到一个txt文本中，如果下次下载检测到存在这个txt文件，就读取内容保存到TArray<fstring>中，根据这些信息就可以恢复进度继续下载。</fstring></fstring></p>
<p>每一个被拆分的出来的小任务PartialTask定义如下：</p>
<pre><code>class PartialTask {
public:
    PartialTask(class DownloadPakFileTask* InParent, FString&amp; InFileName, bool InbFinished, FString&amp; InRange, FString&amp; InSavePath)
        : PakFileTask(InParent), FileName(InFileName), bFinished(InbFinished), Range(InRange), SavePath(InSavePath), IsRunning(false) {}
    DownloadPakFileTask* PakFileTask;
    FString FileName;
    bool bFinished; //是否下载任务已经完成
    FString Range;
    FString SavePath;
    bool IsRunning;//是否任务正在下载
    void SendPartialTaskHttp();
};</code></pre><pre><code>void PartialTask::SendPartialTaskHttp() {
    FString URL = PakFileTask-&gt;Parent-&gt;GetResURL(FileName, PakFileTask-&gt;PakMd5);
    TSharedRef&lt;IHttpRequest&gt; HttpRequest = FHttpModule::Get().CreateRequest();
    HttpRequest-&gt;SetURL(URL);
    HttpRequest-&gt;SetVerb(TEXT(&quot;GET&quot;));
    HttpRequest-&gt;SetHeader(TEXT(&quot;Range&quot;), Range);
    HttpRequest-&gt;OnProcessRequestComplete().BindLambda([&amp;](FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded) {
        IsRunning = false;
        if (!bSucceeded) {
            UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask(%s) fail&quot;), *SavePath);
            PakFileTask-&gt;FinishOnePartialTask(); //bFinished = false
        }
        else {
            if (PakFileTask-&gt;Parent-&gt;bTest) {
                FString log = FString::Format(TEXT(&quot;PartialTask({0}) succeed&quot;), { SavePath });
                GEngine-&gt;AddOnScreenDebugMessage(INDEX_NONE, 300.0f, FColor::Orange, log, true);
                UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask(%s) succeed&quot;), *SavePath);
            }

            FFileHelper::SaveArrayToFile(HttpResponse-&gt;GetContent(), *SavePath);
            bFinished = true;
            PakFileTask-&gt;SuccessfulPartialTaskCount++;
            PakFileTask-&gt;FinishOnePartialTask();
        }
    });
    //HttpRequest-&gt;OnRequestProgress().BindLambda([&amp;](FHttpRequestPtr HttpRequest, int32 BytesSent, int32 BytesReceived) {
    //    UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask:%d, PakFileTask-&gt;PakFileSize:%d&quot;), PakFileTask, PakFileTask-&gt;PakFileSize);
    //});
    //UE_LOG(LogTemp, Warning, TEXT(&quot;PartialTask::SendPartialTaskHttp()&quot;));
    IsRunning = true;
    HttpRequest-&gt;ProcessRequest();
}</code></pre><p>总体的步骤和之前下载多个小文件是类似的，CurHostIndex可以用来进行多轮、变换host地址下载。同时进行多个PartialTask。当下载任务全部完成之后，就开始拼接每一个文件，组合成最后的pak文件。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对要保存一个新文件，或者对已存在文件增添新内容：</p>
<pre><code>void AMyActor::WriteFile(FString&amp; SavePath, TArray&lt;uint8&gt;&amp; Content) {
    if (!FPaths::FileExists(SavePath)) {
        FFileHelper::SaveArrayToFile(Content, *SavePath);
    }
    else {
        FArchive* FileWriter = IFileManager::Get().CreateFileWriter(*SavePath, EFileWrite::FILEWRITE_Append);
        FileWriter-&gt;Serialize(Content.GetData(), Content.Num());
        FileWriter-&gt;Close();
    }
}</code></pre>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/2019-05-16-UE4安卓相关路径/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/16/2019-05-16-UE4安卓相关路径/" class="post-title-link" itemprop="url">UE4安卓相关路径</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-16T00:00:00+08:00">2019-05-16</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-23 12:47:05" itemprop="dateModified" datetime="2019-05-23T12:47:05+08:00">2019-05-23</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天在测试UE4打包的时候顺便在安卓机上输出了一些相关路径，做个记录</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>直接上结论：UE4打包后对应到安卓平台主要有两个目录路径</p>
<p>1、FPaths::ProjectPersistentDownloadDir()</p>
<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/1.jpg" alt="image"></p>
<p>根据FPaths的注释，这是专门为了下载的数据持续化存储的一个可写入的文件夹，应该是对应于Unity的persistentDataPath。在安卓上的输出结果为:</p>
<p>“/storage/emulated/0/Android/data/com.YourCompany.AndroidFirst/files”</p>
<p>在手机上打开安卓文件管理器可以看到一个叫做Android的目录，进入Android文件夹然后按顺序就可以找到files文件夹</p>
<p>2、“../../../”开头的路径</p>
<ul>
<li><p>FPaths::RootDir() 在安卓上的输出结果为 “../../../“</p>
</li>
<li><p>FPaths::ProjectDir() 在安卓上的输出结果为 “../../../AndroidFirst/“</p>
</li>
<li><p>FPaths::EngineDir() 在安卓上的输出结果为 “../../../Engine/“</p>
</li>
<li><p>其他路径基本是以ProjectDir或者EngineDir为基础的路径</p>
</li>
</ul>
<p>FPaths::RootDir()在安卓平台上输出结果上是“../../../”，路径上对应/storage/emulated/0/UE4Game/AndroidFirst</p>
<p>AndroidFirst是我的项目名。</p>
<p>FPaths::ProjectDir()对应/storage/emulated/0/UE4Game/AndroidFirst/AndroidFirst/</p>
<p>FPaths::EngineDir()对应/storage/emulated/0/UE4Game/AndroidFirst/Engine/</p>
<p>如图</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/2.jpg" width="300px">

<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>代码：将路径打印到游戏界面上，并保存到本地文件</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/3.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/4.jpg">

<p>在手机上运行后界面上的打印信息如下</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/5.jpg">

<p>根据/storage/emulated/0/Android/data/com.YourCompany.AndroidFirst/files路径可在安卓上找到对应的文件。首先手机进入文件管理器下找到Android文件夹，YourCompany是依据游戏的打包时候的签名设置，接着根据目录找到paths.txt</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/6.jpg" width="300px">
    <img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/7.jpg" width="300px">
</center>

<p>成功找到生成的paths.txt文件，传到电脑打开该文件</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/8.jpg">

<p>第一行对应的FPaths::ProjectPersistentDownloadDir() 可写路径。剩下的就是以”../../..”开头的路径。</p>
<p>在手机上进入文件管理器后除了Android目录与UE4有关，还有一个UE4Game的文件夹</p>
<center class="half">
    <img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/9.jpg" width="300px">
    <img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4AndroidPath/10.jpg" width="300px">
</center>

<p>UE4Game这个文件夹猜测应该是所有跟UE4有关的项目都放在这里，例如我的AndroidFirst项目，点击进入AndroidFirst项目后才是FPath::RootDir()对应的路径。如果有其他的游戏项目比如AndroidSecond，那么UE4Game还有有第二个文件夹AndroidSecond。</p>
<p>在代码中还把文件保存到FPaths::ProjectDir() / TEXT(“paths.txt”) 也就是”../../../AndroidFirst/“目录，进入文件夹/storage/emulated/0/UE4Game/AndroidFirst/AndroidFirst/“，在这里找到了paths.txt文件。说明“../../../”在路径上是对应“/storage/emulated/0/UE4Game/AndroidFirst/”</p>
<p>由此就可以推出其他几个FPaths中常用的路径：</p>
<p>FPaths::RootDir()在安卓平台上输出结果上是“../../../”路径上对应/storage/emulated/0/UE4Game/AndroidFirst</p>
<p>这个目录文件夹下有AndroidFirst和Engine两个路径</p>
<p>FPaths::ProjectDir()是对应的”../../../AndroidFirst/“</p>
<p>FPaths::EngineDir()是对应的”../../../Engine/“</p>
<p>ps: 我是通过数据线连接到电脑，通过USB调试模式，在UE的启动中，直接选择手机调试的，这种选择发布到手机上的应用应该是Debug签名。因为Develop和Shipping模式的打开手机文件管理器是看不到一些关键的文件的，例如uproject等，只能看到一些ini、log文件。根据网上查阅的资料，想要看到这种文件要么是Debug签名的应用，要么取得Root权限。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/2019-04-25-UE4资源加载（四）UnrealPak打包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/25/2019-04-25-UE4资源加载（四）UnrealPak打包/" class="post-title-link" itemprop="url">UE4资源加载（四）UnrealPak打包</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-04-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-25T00:00:00+08:00">2019-04-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-25 17:07:21" itemprop="dateModified" datetime="2019-05-25T17:07:21+08:00">2019-05-25</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章讲完了从pak中加载出资源文件的过程，那么pak是如何打包生成的呢？pak是分为游戏主体包和后续补丁包两种的，两种又有什么区别呢？这是本篇文章的内容。在UE4打包的时候会启动UAT打包工具，UAT会经历烘焙内容等阶段，最后调用UnrealPak的方法将资源文件打包成pak文件。上一篇文章提到过pak打包与读取是序列化与反序列化的过程，两者是可以互相印证的。本篇文章是pak打包的过程，所以在读代码的时候，不妨与FPakPlatformFile.cpp的内容互相对比。</p>
<p>在4.18版本，Unreal Pak的相关代码是放在UnrealPak.cpp底下的。在4.21版本则是写到了PakFileUtilities.cpp里。文章以4.21版本为准。</p>
<h2 id="UnrealPak打包过程"><a href="#UnrealPak打包过程" class="headerlink" title="UnrealPak打包过程"></a>UnrealPak打包过程</h2><p>以下主要以打游戏的主体包为例。</p>
<h4 id="1、UAT命令"><a href="#1、UAT命令" class="headerlink" title="1、UAT命令"></a>1、UAT命令</h4><p>打包的时候可以在对应的UE的控制台找到UnrealPak的相关日志，文章是用的ProjectLauncher来打包，在ProjectLauncher.log 打包日志中可以看到一句</p>
<p>Running: D:\Program Files\Epic Games\UE_4.21\Engine\Binaries\Win64\UnrealPak.exe D:\MyUnrealProjects\second\second.uproject -batch=”D:\Program Files\Epic Games\UE_4.21\Engine\Programs\AutomationTool\Saved\UnrealPak-Commands.txt”</p>
<p>这个txt包含了对UnrealPak如何打包的具体命令。</p>
<p>相关的UAT代码如下，其中RunAndLog即启动UnrealPak.exe。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/1.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/2.jpg">

<p>参考官网文档，文章用电脑打包以创建Release版本，其中电脑的txt命令内容如下</p>
<p>C:\Users\ZL0032\Desktop\UE_Launcher\NoIncludeEditorContetn\WindowsNoEditor\second\Content\Paks\second-WindowsNoEditor.pak -create=”C:\Users\ZL0032\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Program+Files+Epic+Games+UE_4.21\PakList_second-WindowsNoEditor.txt” -cryptokeys=D:\MyUnrealProjects\second\Saved\Cooked\WindowsNoEditor\second\Metadata\Crypto.json -order=D:\MyUnrealProjects\second\Build\WindowsNoEditor\FileOpenOrder\CookerOpenOrder.log -patchpaddingalign=2048 </p>
<p>命令里首先是打包完成后pak的存储位置，没有以”-”开头。随后是</p>
<ul>
<li>-create </li>
<li>-cryptokeys </li>
<li>-order </li>
<li>-patchpaddingalign=2048</li>
</ul>
<p>-create是获取到一个txt文件，这个txt文件保存了当前版本的资源文件列表。</p>
<p>-order 保存烘焙文件和烘焙文件对应的order顺序</p>
<p>接下来就是具体的打包过程，其中可以分为两步骤，<strong>收集需要打包的文件</strong>以及<strong>生成pak文件</strong>的过程。</p>
<h4 id="2、收集打包文件"><a href="#2、收集打包文件" class="headerlink" title="2、收集打包文件"></a>2、收集打包文件</h4><p>收集打包文件是将每个资源文件整理成FPakInputPair，保存在一个TArray<fpakinputpair> FilesToAdd里，每个FPakInputPair保存打包时候的具体信息，比如是否压缩，烘焙文件在电脑上的地址等。</fpakinputpair></p>
<p>前文提过命令行中的-create之后txt文件就是当前版本资源文件的列表。发布Release版本也就是主体包直接用这个资源列表就可以了，打补丁包的时候会有所不同，将在后面补充。</p>
<p><strong>读取create的txt文件</strong></p>
<p>首先读取txt中存储的内容，txt以每行对应一个文件的形式的存储，每一行又分为三部分，前一部分保存烘焙后的文件在电脑上的地址，第二部分是记录到pak中的地址（在new FPakFile会构建文件夹路径-文件名-索引的结构，这个路径正是用来构建这个结构的），第三部分是这个资源对应的一个标签，例如-compress，表明这个资源打包的时候是需要压缩的，这样有助于减少pak的文件大小。如下</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/3.jpg">

<p>“D:\MyUnrealProjects\second\Saved\Cooked\WindowsNoEditor\second\AssetRegistry.bin” “../../../second/AssetRegistry.bin” -compress</p>
<p>将这个txt读取到TArray<fstring> Lines中，每一行即代表一个资源，Lines.Num()即代表资源的数量。遍历Lines，把每一行的第一部分（本地烘焙文件地址）保存为Source，第二部分（保存到pak中的地址）保存为Dest，第三部分（-compress标签）保存为Switches。这三部分信息保存到一个FPakInputPair里，在把这个Pair保存进TArray中。</fstring></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/4.jpg">

<p><strong>读取order的txt文件</strong></p>
<p>这样就读取了-create的所有信息，并生成了FPakInputPair的数组，接着再取出-order保存的txt文件。如图</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/5.jpg">

<p>其中second是我这个工程的目录，以六个省略号开头的是我本地的资源。</p>
<p>order命令的txt文件的读取和create命令的txt文件读取是类似的，每一行代表一个资源，左边是资源打到pak路径，相当于之前的FPakInputPair的Dest。右边是这个资源的SuggestOrder，建议顺序。每一个资源如果路径匹配则赋予对应的SuggestOrder，如果找不到则SuggestOrder默认为MAX_uint64。在对所有FPakInputPair赋予SuggestOrder后，将会对这个数组重新按照从小到大的顺序排序。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/6.jpg">

<p>PS: 这个order命令其实让人很难捉摸，因为按照或者不按照这个顺序打入pak包，对最后似乎是没有太大影响的。而且对SuggestOrder赋值，似乎仅仅是对系统自带的资源有效，就是指“../../../Engine”开头的资源，而六个省略号开头的项目内的资源反而是没有赋值的。这样的结果就是优先打入引擎自带的资源，项目资源被最后才被打入包里。在我看我似乎影响不大</p>
<h4 id="3、生成pak文件"><a href="#3、生成pak文件" class="headerlink" title="3、生成pak文件"></a>3、生成pak文件</h4><p>收集打包文件之后就可以开始生成pak文件了。</p>
<pre><code>bool bResult = CreatePakFile(*PakFilename, FilesToAdd, CmdLineParameters, SigningKey, EncryptionKey);</code></pre><ul>
<li>PakFilename是pak打包完成后的保存地址</li>
<li>FileToAdd保存了本次pak打包的每个资源的信息。由之前的收集打包文件过程收集而来。</li>
</ul>
<p>之前的文章曾经提过pak文件的格式，如下图。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/7.jpg">

<p>打包的过程其实就是依次从上往下写入的过程，CreatePakFile函数首先建立一个FPakInfo和TArray<fpakentrypair> Index的数组，随后将资源文件逐个写入，每个写入完毕之后，就将文件的偏移、大小记录到FPakInputPair中并加入到Index，等所有的资源全部写入后，也就是完成了文件内容区的写入后，就开始写入Index，文件索引区。写入文件索引区后，再次记录文件索引区的偏移情况以及大小到FPakInfo中，最后写入FPakInfo。这样就完成了一个pak文件。在之前的文章中有提到过new FPakFile构建文件夹路径-文件名-索引的过程，在这个过程中就是因为FPakInfo的大小固定，而且在文件末尾，所以非常方便可以读取到这部分信息，从而读取到文件索引区的。序列化与反序列化是一一对应的！</fpakentrypair></p>
<p>如图，在代码一开始就建立一个FPakInfo和TArray<fpakentrypair> Index的数组。</fpakentrypair></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/8.jpg">

<p>在把资源文件打入文件内容区的时候，还会根据是否是本体包或者补丁包而有所区别，也在补丁包模块中讲。</p>
<h2 id="UnrealPak打补丁包"><a href="#UnrealPak打补丁包" class="headerlink" title="UnrealPak打补丁包"></a>UnrealPak打补丁包</h2><p>下面将介绍打补丁包与打主体包的不同</p>
<ul>
<li><p>UAT传入的命令不同</p>
</li>
<li><p>收集文件步骤不同</p>
</li>
<li><p>CreatePakFile对已删除的文件的处理不同</p>
</li>
</ul>
<h4 id="1、UAT命令不同"><a href="#1、UAT命令不同" class="headerlink" title="1、UAT命令不同"></a>1、UAT命令不同</h4><p>在打补丁包的时候，启动UnrealPak的命令如下：</p>
<p>C:\Users\ZL0032\Desktop\UE_Launcher\1\WindowsNoEditor\second\Content\Paks\second-WindowsNoEditor_0_P.pak -create=”C:\Users\ZL0032\AppData\Roaming\Unreal Engine\AutomationTool\Logs\D+Program+Files+Epic+Games+UE_4.21\PakList_second-WindowsNoEditor_0_P.txt” -cryptokeys=D:\MyUnrealProjects\second\Saved\Cooked\WindowsNoEditor\second\Metadata\Crypto.json -order=D:\MyUnrealProjects\second\Build\WindowsNoEditor\FileOpenOrder\CookerOpenOrder.log -generatepatch=D:\MyUnrealProjects\second\Releases\1.1\WindowsNoEditor\second-WindowsNoEditor*.pak -tempfiles=”D:\Program Files\Epic Games\UE_4.21\TempFilessecond-WindowsNoEditor_0_P” -patchpaddingalign=2048 </p>
<ul>
<li><p>-create </p>
</li>
<li><p>-cryptokeys </p>
</li>
<li><p>-order </p>
</li>
<li><p>-generatepatch（补丁专用，指定了要比较的Release文件）</p>
</li>
<li><p>-tempfiles</p>
</li>
<li><p>-patchpaddingalign    </p>
</li>
</ul>
<p>Patch版本相比Release版本，主要有两点不同：</p>
<ul>
<li><p>打包文件的名字多了<em>0</em>P结尾，这种名字结尾的pak在FPakPlatformFile读取的时候将获得更高的优先级。</p>
</li>
<li><p>-generatepatch是表明这次要生成的是补丁文件，其后是Release版本的文件路径，补丁包是基于Release包为基础打出的，所以如果本次打包是补丁包，那么必须指明具体的Release版本，在发布Release版本的时候，除了生成对应的pak外，还会在电脑项目工程的Release目录下生成一个以ReleaseVersion为名的文件夹。在打补丁包的时候，此时已经是新版本了，新版本的内容将与先前Release版本的内容逐个资源进行比较，判断新加入、修改、删除的内容，从而打出一个补丁包。</p>
</li>
</ul>
<h4 id="2、收集文件步骤不同"><a href="#2、收集文件步骤不同" class="headerlink" title="2、收集文件步骤不同"></a>2、收集文件步骤不同</h4><p>前文提过命令行中的-create之后txt文件就是当前版本资源文件的列表。Release版本也就是主体包直接用这个列表就可以了。Patch版本会有所不同，新版本与旧版本资源比较后，相同的文件是不需要重复打包的，而有变化的文件，包括删除、新增都需要打包进补丁包。那么如何分析哪些文件是相同的，哪些文件是有变化的呢？</p>
<p>generatepatch后面带了一个地址，这个地址的文件是先前本体pak的一个备份。UE4会找到本体pak，生成FPakFile，并对每一个文件进行分析,记录文件大小以及生成的md5值到FileInfo中，并把结果记录到 TMap&lt;FString, FFileInfo&gt; SourceFileHashes中。FileInfo是用来比较文件的，判断是否有变化。如下</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/9.jpg">

<p>主要方法就是GenerateHashesFromPak，分析pak生成FileInfo。具体代码就不展示了，感兴趣的去看看这个方法即可。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad4/10.jpg">

<p>在对每个文件生成了FileInfo之后，就可以来判断文件是否相同了。</p>
<ul>
<li>GetNewDeleteRecords方法 遍历旧版本的文件，查询文件是否在新版本还存在，如果不存在就表明被删除了。</li>
<li>将GetNewDeleteRecords记录到的已删除的文件的添加到FileToAdd中，以便打包的时候记录。此时FileToAdd中的已删除文件的FPakInputPair的bDeleteRecord已经被标记为true</li>
<li>RemoveIdenticalFiles方法 移除相同的文件。</li>
</ul>
<p>RemoveIdenticalFiles比较复杂。需要遍历每一个资源文件。一个资源文件是对应uasset/uexp组合的或者umap/uexp组合，（还有一些其他格式，如ubulk，这些我不太清楚怎么回事）在遍历资源文件的时候，只判断uasset、umap部分，就是<strong>非uexp的部分</strong>。通过FileIsIdentical方法。这个方法首先去判断新旧版本文件的大小，如果大小不一致，那肯定是有变化的。如果大小一致，那么判断md5值是否一致，只有一致了才判断文件是相同的。才可以从补丁包中移除。</p>
<p>对于文件来说除了自身数据变化，还有可能是移动、删除、新增三种状态。移动其实可以看做是删除和新增的组合吧。不过我没有试验过，应该是没有问题的。这样就完成了收集文件的步骤。</p>
<h4 id="3、CreatePakFile对已删除的文件的处理不同"><a href="#3、CreatePakFile对已删除的文件的处理不同" class="headerlink" title="3、CreatePakFile对已删除的文件的处理不同"></a>3、CreatePakFile对已删除的文件的处理不同</h4><p>对于本体pak来说是不存在已删除文件的，只有新版本与旧版本比较产生的补丁包才会有。</p>
<pre><code>bool bResult = CreatePakFile(*PakFilename, FilesToAdd, CmdLineParameters, SigningKey, EncryptionKey);</code></pre><p>在执行CreatePakFile代码的时候，FileToAdd保存了本次pak打包的每个资源的信息。由之前的收集打包文件过程收集而来。FileToAdd不仅仅有新增加的资源，应该说有变化的资源都会被打包，包括被删除的。当资源是被删除的时候，FileToAdd里对应的FPakInputPair的一个标志位bDeleteRecord会被标记为true，那么在把资源文件打入文件内容区的时候，在知道了这个资源被删除的时候，资源不会再被写入到文件内容区，而是只会记录到index中。这样，在读取资源的时候因为补丁包的优先级，总是优先读取到补丁包，那么索引到这个资源已经是删除的了，就不会继续往本体pak中去加载。这样就完成了不改变本体包的情况下，也可以让资源“删除”的效果，因为本体包虽然存在这个资源，但是却无法被读取到。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/2019-04-25-UE4资源加载（三）FPakPlatformFile相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/25/2019-04-25-UE4资源加载（三）FPakPlatformFile相关/" class="post-title-link" itemprop="url">UE4资源加载（三）FPakPlatformFile相关</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-04-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-25T00:00:00+08:00">2019-04-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-25 14:36:06" itemprop="dateModified" datetime="2019-05-25T14:36:06+08:00">2019-05-25</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是继续上一篇文件责任链的内容，继续讲FPakPlatformFile。上一篇文章中提到在文件责任链模式下，调用OpenAsyncRead这个方法后，就可以具体读取到文件，这里将从这个方法为起点，了解FPakPlatformFile的相关内容。首先看看这个方法在FPakPlatformFile中的实现。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/1.jpg">

<p>首先先简单介绍一下概念，FPakPlatformFile是责任链中专门负责处理pak文件的一环处理器。FPakEntry对应具体要读取的uasset文件，FPakFile对应具体的磁盘上的pak文件。FPakPlatformFile持有一个FPakFile的数组，而FPakFile有包含有多个FPakEntry。（pak可以理解为压缩包，压缩包里有至少一个资源文件，这个文件就是对应FPakEntry）</p>
<p>然后从代码可以了解到，在FindFileInPakFiles方法中传入三个参数，一是读取的文件名字，二三是FPakEntry和FPakFile指针。这个方法返回一个bool值表明是否找到对应的文件，FileEntry被赋值为对应的文件。PakFile被赋值为包含这个FileEntry的pak文件。在找到这个具体的文件FileEntry后，返回一个异步读取的句柄。</p>
<p><strong>我们不关心是如何异步读取的。关注点是FindFileInPakFiles这个方法。</strong></p>
<p>在了解这个方法前必须先了解四点相关内容</p>
<ol>
<li><p>pak文件格式</p>
</li>
<li><p>FPakPlatformFile、FPakFile、FPakEntry的代码结构。</p>
</li>
<li><p>FPakPlatformFile的初始化过程</p>
</li>
<li><p>挂载Mount</p>
</li>
</ol>
<h2 id="四点相关内容"><a href="#四点相关内容" class="headerlink" title="四点相关内容"></a>四点相关内容</h2><h4 id="1、pak文件格式"><a href="#1、pak文件格式" class="headerlink" title="1、pak文件格式"></a>1、pak文件格式</h4><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/2.jpg">

<p>参考文章：<a href="https://zhuanlan.zhihu.com/p/54531649" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54531649</a></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/3.jpg">

<p>在打包成pak的时候是按照从上到下的顺序依次写入的，而在读取pak的时候则是从下至上的顺序。读取pak文件的时候，因为FPakInfo的大小是固定的，只需要用整个pak文件的大小减去FPakInfo的大小就可以知道FPakInfo的偏移，这样就可以完整的读取到FPakInfo信息，继而也就知道了文件索引区的偏移以及大小。序列化文件索引区之后，通过FPakEntryPair就可以知道这个pak中存储了哪些文件，这些文件在pak中的偏移、大小情况。</p>
<p>在4.21版本中，关于打包pak的相关代码在PakFileUtilities.cpp中的CreatePakFile方法中，关于读取pak的相关代码在IPlatformFilePak.cpp中的Initialize和LoadIndex中。</p>
<p>打包以及读取是序列化与反序列化相反的过程，在以上两个方法中可以找到很多对应的部分。</p>
<h4 id="2、FPakPlatformFile、FPakFile、FPakEntry的组织结构。"><a href="#2、FPakPlatformFile、FPakFile、FPakEntry的组织结构。" class="headerlink" title="2、FPakPlatformFile、FPakFile、FPakEntry的组织结构。"></a>2、FPakPlatformFile、FPakFile、FPakEntry的组织结构。</h4><ul>
<li><p>FPakPlatformFile是文件责任链中负责处理pak相关的一环处理器</p>
</li>
<li><p>FPakFile对应磁盘上的一个pak文件</p>
</li>
<li><p>FPakEntry对应pak中存储的单个资源文件</p>
</li>
<li><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/4.jpg">



</li>
</ul>
<p><strong>FPakPlatformFile</strong></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/5.jpg">

<p>LowerLevel不必说，是指向责任链的下一环。</p>
<p>FPakListEntry是由两部分组成，一个是ReadOrder，另一个是FPakFile，也就是具体的Pak文件。    TArray<fpaklistentry> PakFiles也就是保存所有挂载的Pak文件，同时这些pak文件根据ReadOrder从大到小排序。</fpaklistentry></p>
<p><strong>FPakFile</strong></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/6.jpg">

<p>Pak中存储了很多资源文件，FPakEntry对应一个具体的资源文件，在TArray<fpakentry> Files中保存了所有的文件。每个文件在Files中都有一个对应的索引。</fpakentry></p>
<p>TMap&lt;FString, FPakDirectory&gt; Index；是一个路径名到FPakDirectory的映射，而FPakDirectory定义为TMap&lt;FString, int32&gt;。这又是一个文件名到一个具体数字的映射。这个具体的数字就是这个文件在Files中的索引。综上来看，在读取一个文件的时候，也就是传入一个文件名字的时候，是将文件名分解为文件夹路径名+文件具体名字。然后通过文件夹路径名和文件具体名字的映射得到一个索引，这样就能够知道文件对应哪一个FPakEntry。</p>
<p><strong>FPakEntry</strong></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/7.jpg">

<p>通过注释就可以知道 一个FPakEntry对应保存在pak file中的单个文件。FPakEntry记录了这个资源文件的大小，以及在pak中的偏移位置等。</p>
<h4 id="3、FPakPlatformFile的初始化过程（找到pak文件并挂载）"><a href="#3、FPakPlatformFile的初始化过程（找到pak文件并挂载）" class="headerlink" title="3、FPakPlatformFile的初始化过程（找到pak文件并挂载）"></a>3、FPakPlatformFile的初始化过程（找到pak文件并挂载）</h4><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/8.jpg">

<p>如图所示初始化主要分为三个步骤：</p>
<ul>
<li><p>指定这个处理器的LowerLevel下一环处理器。</p>
</li>
<li><p>找到所有Pak文件夹并挂载所有Pak文件。</p>
</li>
<li><p>指定一些委托函数。例如想手动挂载某个pak或者卸载pak那么将会触发对应的方法。</p>
</li>
</ul>
<p>这三个步骤中重点是第二个步骤找到pak文件并挂载。首先是找到对应的Pak文件夹</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/9.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/10.jpg">

<p>UE4将通过硬编码的形式，指定三个文件夹，其中第一个文件夹 ProjectContentDir + “Paks/“是我们打出来的包存放的文件夹。如图。找到所有PAK对应的文件夹后是挂载这些文件夹中的pak文件</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/11.jpg">

<p>挂载所有pak的过程分为三个步骤：</p>
<ul>
<li><p>找到文件夹下的pak文件</p>
</li>
<li><p>找到已挂载的pak文件</p>
</li>
<li><p>具体挂载单个pak文件</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/12.jpg">

<p>挂载单个pak文件，首先是与已经挂载的pak文件进行比较，过滤重复挂载的pak文件。接着每一个pak文件必须有读取的先后顺序，得到先后顺序后，通过Mount方法挂载上。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/13.jpg">

<p>pak的顺序与所在文件目录有关，在ProjectContentDir下的文件优先级最高。随后将pak文件名字与pak优先级传入Mount方法里。</p>
<h4 id="4、挂载Mount"><a href="#4、挂载Mount" class="headerlink" title="4、挂载Mount"></a>4、挂载Mount</h4><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/14.jpg">

<p>在找到pak文件后接着就是挂载的过程，挂载可以理解为把pak的包含了哪些内容生成一个目录，并加入到PakFiles中，查找文件的时候，遍历这些PakFiles，根据生成的目录可以快速索引是否这个pak文件的目录包含查找文件。对之前的FPakPlatformFile的结构图来说也就是构造红线的部分。新生成一个FPakFile，指定优先级顺序，加入到PakFiles中。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/15.jpg">

<p>挂载主要也主要分成三步骤：</p>
<ul>
<li><p>生成FPakFile。</p>
</li>
<li><p>如果是补丁文件则提高补丁文件的优先级</p>
</li>
<li><p>将FPakFile添加到FPakPlatformFile上，排序。<strong>（指定顺序与补丁包的使用有关，最后再说）</strong></p>
</li>
</ul>
<p><strong>生成FPakFile</strong></p>
<p>加载pak文件信息区以及文件索引区。知道这个pak的相关信息，存储了多少文件等等。对这些文件构建对应的路径-文件名-索引的结构。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/16.jpg">

<p>在Initialize函数里，首先需要读取pak文件中pak文件信息区的内容（PAK文件格式分成三部分，文件资源区，文件索引区，pak文件信息区）。pak文件信息区(对应一个FPakInfo)存放整个PAK的信息，FPakInfo是固定格式的。把整个文件大小减去FPakInfo的大小就是FPakInfo在pak文件中的偏移，（因为FPakInfo在文件的最后部分），如下图。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/17.jpg">

<p>在得到了pak文件信息区的内容后，接着就可以知道索引区的数量，偏移位置等等。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/18.jpg">

<p>在得到Pak文件信息区的内容后，接着读取文件索引区的内容。将这一部分的内容加载到内存了，首先读取MountPoint和NumEntries。接着读取TArray<fpakentrypair> Index的内容。</fpakentrypair></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/19.jpg">

<p>这一部分相当于是把索引区的内容给读取进来，然后读取挂点以及索引区的数量</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/20.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/21.jpg">

<p>首先是读取到资源文件的名字，接着序列化得到整个Entry。然后是根据这个名字构建对应的文件夹路径-文件名-索引的关系</p>
<p>获得这个资源名字的文件夹路径Path，在保存的Index中寻找是否已存在文件夹，把索引和文件名字放入这个文件夹。</p>
<ul>
<li><p>FPaths::GetPath(Filename); 获得文件的路径</p>
</li>
<li><p>FPaths::GetCleanFilename(Filename)  获得文件的名字 包含后缀</p>
</li>
<li><p>Filename = 路径 + 名字 = FPaths::GetPath(Filename) + FPaths::GetCleanFilename(Filename)</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/22.jpg">

<p>构建文件夹路径-文件名-索引这种结构是为了方便在寻找一个文件的时候能够利用Hash快速索引至正确位置，把传入的名字拆分得到文件夹路径和文件名，这样就可以得到索引，索引对应TArray中的资源的位置，这样就快速索引到了资源。完成以上步骤后就正确生成了FPakFile。</p>
<p><strong>如果是补丁文件则提高补丁文件的优先级</strong></p>
<p>​       补丁文件的以 _ 数字_P.pak 这种形式结尾，读取到其中的数字，再加上1，和值乘上100加到原先的优先级上。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/23.jpg">

<p>仍然以此图为例，本体包优先级为4，补丁包为 （0+1）*100 + 4。如果后面出新的补丁包，后缀为1、2、3。优先级就是204、304、404。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/24.jpg">

<p><strong>将FPakFile添加到FPakPlatformFile上，排序。</strong></p>
<p>每挂载上一个PAK文件，就是添加到FPakPlatformFile的数组上，并且按照从大到小顺序排。按照从大到小的顺序与资源加载是有关的。如果在本体包中的一个文件，在日后的更新中删除的时候，那么这个文件也会打到补丁包上，相当于只是记录到补丁包中，这个文件已经被删除了。这样读取的时候，优先读取补丁包，知道这个文件已经被删除了，就不会继续往低优先级的pak文件中搜索。这样虽然原来的本体包中存在资源文件，但是却不会被访问到，效果上相当于删除了。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/25.jpg">

<p>通过生成FPakFile（读取Pak文件信息区和文件索引区再构建路径-文件名-索引的结构），指定优先级顺序，加入到PakFiles并排序，这样就完成了挂载Mount的过程。</p>
<p>网上有问题探讨Mount挂载和加载到内存的区别，通过以上分析，可以知道Mount其实是只加载部分pak的文件信息到内存，这部分信息是这个pak存储了多少文件，文件在什么位置等等。并没有加载具体的文件信息。只有用到了具体的文件信息才会去读取。</p>
<h2 id="FindFileInPakFiles"><a href="#FindFileInPakFiles" class="headerlink" title="FindFileInPakFiles"></a>FindFileInPakFiles</h2><p>讲完了以上四点之后，接着就是回到开头的问题了，从文件责任链开始的OpenAsyncRead之后是如何找到正确的文件的。</p>
<p>依据FPakPlatformFile的结构图简单来说就是，遍历所有挂载的Pak文件，每个Pak文件都有一个路径-文件名-索引的结构，我们将文件的名字拆分成这种路径加文件名，快速取得索引，这样就可以在Files中取得正确的FPakEntry。</p>
<p>下面是具体的代码</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/26.jpg">

<p>FindFileInPaiFiles方法如下，找到所有已经挂载的pak，并且从pak中寻找正确的文件</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/27.jpg">

<p><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/28.jpg">其核心代码是这一段</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/29.jpg">

<p>对挂载的每一个Pak做一个遍历操作，每一个Pak都调用Find方法寻找文件</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad3/30.jpg">

<p>在Find方法中，通过FileName分割为对应的文件夹路径和具体文件资源的名字</p>
<p>先通过文件夹路径找到指定文件夹FPakDirectory，接着再通过具体资源名字在FPakDirectory找到具体索引。通过具体索引就可以在TArray存储所有FPakEntry的数组中找到具体索引的资源文件，这样就找到了正确的FPakEntry。</p>
<p>FPakEntry只是记录了这个资源文件在这个Pak中的偏移位置，以及文件大小等。剩下的就是由读取文件的系统去实际的读取这一部分数据。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>至此文章的主题部分就结束了，从OpenAsyncRead方法入手，了解了FPakPlatformFile的代码结构，初始化过程等。也明白了是如何找到FPakEntry的。思考一下，UE4的这种设计结构如何来配合UE4的打包。Unity的策略是，每一个文件一个Bundle，手动管理依赖关系。加载的时候加载依赖文件，这样来加载整个物体。UE4也是可以做到一样的，每一个文件单独打成一个Pak，然后AssetRegistry是可以导出文件的依赖与被依赖关系的。但是结合之前FindFileInPakFiles的代码，如果我们在游戏初始化的时候就挂载所有Pak文件，读取资源的时候逐个遍历这些Pak，这样的效率是不高的。相比之下如果把资源文件打包成一个Pak，那么寻找资源的时候就可以通过Hash的方法快速找到资源。两种方法就是遍历与哈希的时间复杂度的比较。如果坚持一个资源一个Pak的话，那么手动管理Pak的挂载与释放可以减少挂载的Pak，减少遍历的时间，但这相当于必须记录它们之间的依赖引用关系，做法相对来说也是比较麻烦的，而且也有Pak挂载与Pak释放的消耗。所以应该说Pak中更适合放多个文件的。</p>
<p>UE4的Pak可以分为游戏的主体包，与后续的补丁包。而且它在ProjectLauncher里也提供了非常方便的打包工具，接下来将会介绍UE4的打包相关的内容。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/2019-03-27-UE4资源加载（二）文件责任链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/27/2019-03-27-UE4资源加载（二）文件责任链/" class="post-title-link" itemprop="url">UE4资源加载（二）文件责任链</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-27 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-27T00:00:00+08:00">2019-03-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-05-24 20:43:26" itemprop="dateModified" datetime="2019-05-24T20:43:26+08:00">2019-05-24</time>
              </span>
            
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        这是关于资源加载的第二篇内容，前一篇内容讲了，从StaticLoadObject出发，是如何把自身的数据以及依赖对象的数据给加载到内存中的，这一篇内容将继续讲文件读取的相关内容。</p>
<h2 id="责任链设计模式"><a href="#责任链设计模式" class="headerlink" title="责任链设计模式"></a>责任链设计模式</h2><p>​        在进入主题之前必须先了解一下UE4为了文件读取所采用的设计模式，责任链设计模式。这是网上找的一篇讲解 <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html" target="_blank" rel="noopener">http://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html</a></p>
<p>　　来考虑这样一个功能:申请聚餐费用的管理。</p>
<p>　　很多公司都是这样的福利，就是项目组或者是部门可以向公司申请一些聚餐费用，用于组织项目组成员或者是部门成员进行聚餐活动。</p>
<p>　　申请聚餐费用的大致流程一般是：由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。</p>
<p>　　不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。</p>
<p>　　也就是说，当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。</p>
<p>　　可以使用责任链模式来实现上述功能：当某人提出聚餐费用申请的请求后，该请求会在 <strong>项目经理—〉部门经理—〉总经理</strong> 这样一条领导处理链上进行传递，发出请求的人并不知道谁会来处理他的请求，每个领导会根据自己的职责范围，来判断是处理请求还是把请求交给更高级别的领导，只要有领导处理了，传递就结束了。</p>
<p>　　需要把每位领导的处理独立出来，实现成单独的职责处理对象，然后为它们提供一个公共的、抽象的父职责对象，这样就可以在客户端来动态地组合职责链，实现不同的功能要求了。</p>
<p>​        项目经理可以解决（完成 ），不可以解决-&gt;抛给部门经理去处理-&gt;部门经理不能解决再抛给总经理去处理。各人负责各自领域内的责任 。</p>
<h2 id="UE4文件责任链"><a href="#UE4文件责任链" class="headerlink" title="UE4文件责任链"></a>UE4文件责任链</h2><p>在UE4中对文件读取也采用了责任链的设计模式。好处是将负责一类功能的（比如专门负责读取Pak文件）给单独抽取了出来，保持类的单一职责。在这个链上的各个处理器只负责分内的事，如果请求不是自己处理直接抛给下一个就好了。链上的每一个环都继承自IPlatformFile接口。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad2/2.jpg">

<p><a href="https://zhuanlan.zhihu.com/p/35925797" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35925797</a></p>
<p>在加载uasset文件的时候调用到了方法</p>
<p><code>Handle = FPlatformFileManager::Get().GetPlatformFile().OpenAsyncRead(InFileName);</code></p>
<p>其中FPlatformFileManager 是一个单例的管理器，持有一个TopmostPlayformFile，也就是责任链的头部位置。每个具体实现的类在初始化的时候都会持有下一个IPlatformFile的引用。这样TopmostPlayformFile处理不了的文件可以一直往下传递，直到被处理或者传递到链的末尾。</p>
<p>相关方法如下</p>
<pre><code class="c++">FPlatformFileManager 

/** Currently used platform file. */
class IPlatformFile* TopmostPlatformFile; //类里的唯一变量

FPlatformFileManager&amp; FPlatformFileManager::Get() //单例模式
{
  static FPlatformFileManager Singleton;
  return Singleton;
}

IPlatformFile&amp; FPlatformFileManager::GetPlatformFile() //获得链顶部的IPlatform处理器
{
  if (TopmostPlatformFile == NULL)
  {
     TopmostPlatformFile = &amp;IPlatformFile::GetPlatformPhysical();
  }
  return *TopmostPlatformFile;
}</code></pre>
<p><strong>如何生成责任链：</strong></p>
<p>以安卓为例，启动过程：</p>
<ol>
<li><p>在LaunchAndroid.cpp调用AndroidMain 程序入口</p>
</li>
<li><p>调用FEngineLoop::PreInit</p>
</li>
<li><p>在PreInit中调用 LaunchCheckForFileOverride</p>
</li>
<li><p>在LaunchCheckForFileOverride生成读取文件的责任链</p>
</li>
</ol>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad2/4.jpg">

<p>最开始责任链只有一个physical platform file，随后加入读取PakFile的处理器。此时physical platform file为PakFile的LowerLevel，也就是处理器的下一环。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad2/5.jpg">

<p>ConditionallyCreateFileWrapper在获得相应的IPlatformFile之后会调用Initialize初始化方法，CurrentPlatformFile也就成了新生成的IPlatformFile的LowerLevel。</p>
<p><strong>FPakPlatformFile的结构</strong></p>
<p>生成责任链后，链上的每一环各自负责自己的内容，其中FPakPlatformFile是专门处理Pak的一环。这里对FPakPlatformFile只做简要介绍，下一篇内容会详细讲解Pak格式相关。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad2/3.jpg" width="600px">

<ul>
<li><p>LowerLevel 链上下一环处理器</p>
</li>
<li><p>TArray<fpaklistentry> PakFiles存储所有Pak文件</fpaklistentry></p>
</li>
</ul>
<p>FPakPlatformFile的PakFiles 将几个指定目录下所有pak为后缀的文件挂载到内存中，是挂载而不是加载，加载意味着整个pak文件数据都加载到内存中。而挂载不同，pak是打包了很多uasset、uexp文件的这样一个文件。挂载仅仅只是对这些uasset生成一个目录，加载某一个uasset文件的时候，就可以在这个目录下查找，这个pak是否含有这个uasset文件，如果有，才把pak中对应资源相关的数据给加载到内存。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/2019-03-26-UE4资源加载（一）从StaticLoadObject开始/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BAJIAObujie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芭蕉不解的博客">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/2019-03-26-UE4资源加载（一）从StaticLoadObject开始/" class="post-title-link" itemprop="url">UE4资源加载（一）从StaticLoadObject开始</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-03-26T00:00:00+08:00">2019-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-07-31 11:15:05" itemprop="dateModified" datetime="2019-07-31T11:15:05+08:00">2019-07-31</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Diary/" itemprop="url" rel="index"><span itemprop="name">Diary</span></a></span>

                
                
              
            </span>
          

          <br/>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是关于资源加载的第一篇内容，主要从StaticLoadObject出发，讨论UE是如何把序列化的数据给加载到内存中的。了解加载过程前必须先了解UPackage、uasset文件格式、FLinkerLoad。了解这三个概念之后会介绍StaticLoadObject加载过程所经过的四个步骤。</p>
<h2 id="UPackage、uasset、FLinkerLoad"><a href="#UPackage、uasset、FLinkerLoad" class="headerlink" title="UPackage、uasset、FLinkerLoad"></a>UPackage、uasset、FLinkerLoad</h2><p>一个资源在文件中对应uasset，在内存中对应为UPackage。</p>
<h4 id="1、UPackage"><a href="#1、UPackage" class="headerlink" title="1、UPackage"></a>1、UPackage</h4><p>一个资源在内存中表现为一个UPackage的实例，比如一个SoundCue资源，SoundCue内部可能有很多个蓝图节点，就有一些节点的数据，比如Modulator、Mixer等等，这些数据是实例本身的数据。同时SoundCue也引用外部声音文件SoundWave。SoundWave也是一个资源，也是对应的一个UPackage实例。这样两个UPackage之间就存在依赖关系。</p>
<p>UPackage就好比一个班级，底下的数据UObject就好比学生，对于班级（UPackage）底下的同学（UObject）来说，UPackage是UObject的Outer。要知道资源自身数据UObject的内容，必须先知道UPackage才行。</p>
<h4 id="2、uasset文件格式"><a href="#2、uasset文件格式" class="headerlink" title="2、uasset文件格式"></a>2、uasset文件格式</h4><p>UPackage序列化到本地之后就是uasset文件。uasset是本地的资源文件，文件格式如图</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/1.jpg" width="250px">

<ul>
<li><p>File Summary 文件头信息</p>
</li>
<li><p>Name Table 包中对象的名字表</p>
</li>
<li><p>Import Table 存放被该包中对象引用的其它包中的对象信息(路径名和类型)</p>
</li>
<li><p>Export Table 该包中的对象信息(路径名和类型)</p>
</li>
<li><p>Export Objects 所有Export Table中对象的实际数据。</p>
</li>
</ul>
<p>前文提过，两个UPackage实例是可以存在依赖关系的，序列化到uasset文件的时候，这些依赖关系就存储为ImportTable。可以把ImportTable看做是这个资源所依赖的其他资源的列表，ExportTable就是这个资源本身的列表。Unity导出资源的时候是导出AssetBundle + 依赖表。每个资源所依赖的其他资源都记录在依赖表中 。这里的uasset可以看做是AssetBundle + 依赖表中这个资源的依赖文件记录。其中AssetBundle就是对应的ExportTable以及ExportObject的内容，依赖表中这个资源的依赖文件记录就是对应的ImportTable。</p>
<h4 id="3、FLinkerLoad"><a href="#3、FLinkerLoad" class="headerlink" title="3、FLinkerLoad"></a>3、FLinkerLoad</h4><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/2.jpg">



<p>FLinkerLoad是作为uasset和内存UPackage的中间桥梁。在加载内容生成UPackage的时候，UPackage会根据名字找到uasset文件，由FLinkerLoad来负责加载。FLinkerLoad主要内容如下：</p>
<ul>
<li><p>FArchive* Loader; </p>
<p>//Loader负责读取具体文件</p>
</li>
<li><p>TArray<fobjectimport> ImportMap; </fobjectimport></p>
<p>//将uasset的ImportTable加载到ImportMap中，FObjectImport是需要依赖（导入）的UObject</p>
</li>
<li><p>TArray<fobjectexport> ExportMap; </fobjectexport></p>
<p>//FObjectExport是这个UPackage所拥有的UObject（这些UObject都能提供给其他UPackage作为Import）</p>
</li>
</ul>
<p>在了解了基本概念后，接下来进入主要部分，也就是StaticLoadObject加载，StaticLoadObject可以分成四个部分。</p>
<h2 id="加载内容的四个步骤："><a href="#加载内容的四个步骤：" class="headerlink" title="加载内容的四个步骤："></a>加载内容的四个步骤：</h2><ol>
<li><p>根据文件名字创建一个空的包（没有任何文件相关的数据）</p>
</li>
<li><p>建立一个LinkerLoad去加载对应的uasset文件 序列化。</p>
</li>
<li><p>优先加载ImportMap</p>
</li>
<li><p>加载ExportMap（本身的数据）</p>
</li>
</ol>
<p>对应图中右边的四个步骤</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/3.jpg" width="800px">



<p>序列化uasset阶段中会序列化还原这个资源所需要的信息，例如ImportMap、ExportMap，但这两个Map中存储的信息仅仅是Import和Export的信息而已，可以理解为是知道了去加载的途径，但是还没有去加载。随后在VerifyImportInner才会实际上地把Import内容加载进内存，（LoadAllObject + EndLoad）把自身资源的数据加载到内存。</p>
<h4 id="1、建立一个UPackage"><a href="#1、建立一个UPackage" class="headerlink" title="1、建立一个UPackage"></a>1、建立一个UPackage</h4><p>从StaticLoadObject方法逐步看即可，略过</p>
<h4 id="2、序列化uasset"><a href="#2、序列化uasset" class="headerlink" title="2、序列化uasset"></a>2、序列化uasset</h4><p>在FLinkerLoad的Tick函数中，会把uasset的信息给加载出来。</p>
<p><code>FLinkerLoad::ELinkerStatus FLinkerLoad::Tick( float InTimeLimit, bool bInUseTimeLimit, bool bInUseFullTimeLimit )</code></p>
<ul>
<li><p>读取文件 CreateLoader  </p>
</li>
<li><p>序列化FileSummary，SerializePackageFileSummary </p>
<p>FPackageFileSummary 主要存储 比如FolderName基本字段以及uasset其余信息在文件中的偏移信息，比如ExportOffset、ExportCount。</p>
</li>
<li><p>序列化uasset其他信息（除FileSummary、ExportObject）比如：    SerializeImportMap、SerializeExportMap。</p>
</li>
<li><p>生成必要信息，这些信息不需要序列化到uasset，可以通过其余序列化信息恢复生成 CreateExportHash</p>
</li>
<li><p>FinalizeCreation  创建LinkerLoad的最后步骤，verify 加载外部依赖UObject</p>
</li>
</ul>
<p>verify加载外部依赖的时候就进入了第三阶段，加载ImportMap的内容。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/4.jpg" width="250px">



<h4 id="3、加载ImportMap"><a href="#3、加载ImportMap" class="headerlink" title="3、加载ImportMap"></a>3、加载ImportMap</h4><p>ImportMap是一个FObjectImport的数组，存储依赖的UObject，对应的ExportMap也是FObjectExport的数组。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/5.jpg">



<p>verify主要是调用到FLinkerLoad::VerifyImportInner，这个函数主要分为两种情况，加载的UObject是Asset实际资产和非Asset（MemoryOnly），这两种情况还要区别是加载UObject还是UPackage。就是说加载Asset的时候可能只是加载这个资产底下的一个UObject而已，也可能是加载整个UPackage。加载非Asset的时候也有可能是加载UObject或者UPackage。<strong>（UClass和UPackage都是继承自UObject的）</strong></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/6.jpg">

<p>一、Import是一个MemoryOnly。</p>
<p> 1、Import是MemoryOnlyPackage </p>
<p>加载代码里主要用到了这两个函数。</p>
<ul>
<li><p>LoadPackageInternal （主要是加载AssetPackage，不加载MemoryOnlyPackage）</p>
</li>
<li><p>CreatePackage（优先在内存中找，否则创建）</p>
</li>
</ul>
<p>当在LoadPackageInternal加载不到的时候，会继续在CreatePackage中查找，这个函数优先在内存中查找，而MemoryOnly正是提前存在于内存中的。找到UPackage对应的包返回即可，Import.XObject = FindPackage。</p>
<p>（就目前的理解来看，可能有错，加载的MemoryOnly一般是UClass或者包含UClass的UPackage，像SoundWave也是一个UClass，这些UClass包含在 /Script/UnrealEngine的UPackage中，这些UClass类以及UPackage都是在引擎启动的时候就已经加载到内存中的）</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/7.jpg">

<p> 2、Import是一个UObject，那必定是Class对象（类似Java Class对象），找到TopLevelPackage，也就是这个Class对象所在的UPackage，在TopLevelPackage找到这个Class对象并赋值给Import的XObject。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/8.jpg">



<p>比如加载一个SoundWave音频资源文件，在ExportMap中只有一个UObject就是音频数据。但这个音频数据需要SoundWave的类对象，所以在ImportMap中有一个UObject储存类对象，这个SoundWave类对象是属于 /Script/UnrealEngine UPackage里的，/Script/UnrealEngine就相当于保存类对象定义的地方，所以ImportMap中总共有两个UObject，一个是Class对象，一个是Package。加载的时候在UPackage中找到类对象</p>
<pre><code>Sound.uasset
{
  ImportMap[0] SoundWave Class对象
  ImportMap[1] /Script/UnrealEngine UPackage包
  ExportMap[0] 音频数据
}</code></pre><img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/9.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/10.jpg">

<ul>
<li><p>ClassName：Class表明这是一个Class对象、Package表明是一个UPackage</p>
</li>
<li><p>ObjectName:SoundWave表明这个SoundWave类对象</p>
</li>
<li><p>OuterIndex：-2表明这个类对象是放在索引为1的包内</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/11.jpg">

<p>索引换算方法：</p>
<ul>
<li><p>PackageIndex &gt; 0,表示在ExportMap中的索引 实际索引 Index = PackageIndex -1；</p>
</li>
<li><p>PackageIndex &lt; 0,表示在ImportMap中的索引 实际索引 Index = - PackageIndex -1；</p>
</li>
<li><p>PackageIndex = 0,表示当前UPackage对象；</p>
</li>
</ul>
<p>看ExportMap[0]的classIndex为-1，也就是说这个数据的类的数据保存在ImportMap[0]的位置。ImportMap[0]的ClassName为Class表明这是一个类，如果为Package则表明这个Import是一个UPackage。ImportMap[0]是U Package底下的一个UObject，通过ImportMap[0].OuterIndex 可以知道这个UObject的Outer的位置，OuterIndex是-2，也就是说Outer是ImportMap[1]，ImportMap[1]是一个UPackage。</p>
<p>二、Import是一个Asset资源。</p>
<p> 1、Import对应的是一个UPackage，那么会调用LoadPackageInternal，在这个函数里又会根据名字去找到对应的具体文件，然后创建一个新的UPackage。这个步骤有点类似于递归。（先假设已经完成加载Import的AssetPackage，因为LoadPackage过程是一样）, 接着让Import.SourceLinker = NewUPackage.LinkerLoad让Import持有NewUPackage的FLinkerLoad。</p>
<p> 2、Import表示一个UObject，UObject必定属于另一个UPackage(必定有Outer)，先去加载对应的Outer。加载完Outer之后，才加载UObject。一个包对应一个FLinkerLoad，让包1中Import.SourceLinker = 包2的Outer.SourceLinker。同时可以知道，NewUPackage（当作包2）的ExportMap肯定有一个UObject是对应着包1的ImportMap。因为两者存在引用关系。为了加载UObject，通过HashName找到对应的资源的索引，包1的Import.SourceIndex = 包2的ExportMap中对应资源的索引</p>
<p>附：如何寻找正确的SourceIndex </p>
<p>一个资源引用另一个资源，那么必然这个资源的ObjectName（资源名字）、ClassName（类名字，比如SoundWave）、ClassPackage（类所在的Package）。这三点必然是相等的。</p>
<p>在读取文件序列化uasset的过程中，就有一个HashName的过程，即一个Export的ObjectName、ClassName、ClassPackage通过HashName得到一个0-255之间的一个索引，记录在一个0-255的数组中的对应位置记录上这个Export在ExportMap中的索引。</p>
<p>Import中也利用同样的三个值ObjectName、ClassName、ClassPackage，计算出一个同样的索引，在0-255中对应索引的位置上找到这个导出在ExportMap中的位置</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/12.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/13.jpg">

<p>总结：</p>
<p>以上就对四种情况分别做了介绍。</p>
<p>对于MemoryOnly来说，是在Import.XObject中直接记录UPackage指针 或者 UClass对象指针，Import里有一个SourceLinker表示依赖的资源所需要的FArchive，对于MemoryOnly来说是不需要依赖Asset文件的，所以是这个值是NULL。</p>
<p>对于Asset来说，是在Import.SourceLinker中记录资源的Loader，在Import.SourceIndex中记录资源在ExportMap中的位置。这样就可以找到Export.Object</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/14.jpg" width="600px">

<p>其实方法上来讲是很相似的，加载UObject（Import加载UClass Export加载UPackage下的UObject）的时候都会先去要求Outer已经被加载，再从Outer中获取UObject。</p>
<h4 id="4、加载ExportMap自身数据"><a href="#4、加载ExportMap自身数据" class="headerlink" title="4、加载ExportMap自身数据"></a>4、加载ExportMap自身数据</h4><p>加载ExportMap自身数据的部分可以分成两个主要部分，<strong>一是根据CDO类默认对象生成一个模板，二修改差异性的数据。</strong></p>
<p><strong>一、塑造模板的过程如下：</strong></p>
<ol>
<li><p>获得Export.Object的Archetype</p>
</li>
<li><p>根据Class对象、Outer、Name、Template构建模板对象</p>
</li>
<li><p>设置Linker</p>
</li>
</ol>
<p><strong>获得Export.Object的Archetype</strong></p>
<ol>
<li><p>是UPackage，则取得CDO (Class Default Object），相当于类默认构造函数所构建的一个对象，一个类会在内存中放置一个CDO。</p>
</li>
<li><p>不是UPackage，则应该是UPackage下的一个UObject，必须先加载到Outer，从Outer中加载原型。加载Outer的时候会一直追溯到UPackage。最后取得的UObject就相当于是CDO中对应的部分。</p>
</li>
</ol>
<p>如果是UPackage则返回一个CDO。</p>
<p>如果有Outer也就是说不是UPackage 则从outer中找到原型 再从原型中找到对应的component，因为outer-&gt;getArchetype最终一定有一个Top-Level Package，这样必定返回一个类的默认对象。</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/15.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/16.jpg">

<p><strong>根据Class Outer Name Template构建模板对象</strong></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/17.jpg">

<p>在内存中重新构建出来一个UObject</p>
<p>LoadClass 这个Object对应的类</p>
<p>ThisParent 这个Object对应的Outer</p>
<p>Template 这个Object对应的模板</p>
<p><strong>设置Linker</strong></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/18.jpg">

<p>设置Export.Object对应的Linker，并添加到ObjLoaded中，在EndLoad中重新拿到ObjLoaded（需要加载的所有Export）随后真正的序列化这个物体。</p>
<p><strong>二、EndLoad调用PreLoad方法实现序列化</strong></p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/19.jpg">

<p>FAA2即FArchive下的Loader对象，与uasset文件直接关联。</p>
<p>Export包含了这个Object导出所存储的必要信息，在文件中的起始偏移值，文件大小。将内容加载至内存随后序列化</p>
<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/20.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/21.jpg">

<img src="https://raw.githubusercontent.com/BAJIAObujie/BAJIAObujie.github.io/master/img/UE4ResourceLoad1/22.jpg">

<p><a href="https://yuedu.163.com/book_reader/abb2cf428b244522b17aa2ec9eeea88c_4/dfd26a58c22643bf95b8a473352d5b4c_4" target="_blank" rel="noopener">https://yuedu.163.com/book_reader/abb2cf428b244522b17aa2ec9eeea88c_4/dfd26a58c22643bf95b8a473352d5b4c_4</a></p>
<p><strong>总结：</strong></p>
<p>至此四个步骤就已经结束了，第一部分创建了一个UPackage。第二部分将读取的uasset部分数据加载到FLinkerLoad中，此时FLinkerLoad就已经知道了这个资源依赖哪些资源，自身又有哪些资源。第三部分加载ImportMap。第四部分加载ExportMap，其中加载自身数据的这个过程又分为两步，先是依据类模板对象生成一个模板，随后才序列化差异的数据。类模板对象UClass总是在ImportMap中，这可能也是为什么要先加载ImportMap的原因。</p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>当资源1依赖于资源2的时候，也就是加载包1的过程中必须加载包2，例如一个SoundCue依赖于一个SoundWave，加载资源2时是根据名字去Pak中搜索对应的uasset。找到对应的uasset之后，包1ImportMap与包2ExportMap中对应的UObject 建立关联需要保证三个值不变ObjectName ClassName ClassPackage。</p>
<p>场景1：要更改一个资源，比如只是简单的音乐替换的话，那么ClassName ClassPackage肯定是不变的,只需要保证ObjectName不变即可。打包后，将修改后的音频资源的Pak直接替换，那么游戏的音乐就修改成功。如果需要改变ClassName ClassPackage的话，那么必须同时修改两个包才可以！ </p>
<p>场景2：如果给SoundCue增加了很多功能，比如蓝图中的Mixer，Modulator。这样会增加SoundCue的依赖的Class对象，以及自身Export中的数据，与依赖的文件资源时没有关系的，这种情形下直接替换Pak即可</p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul>
<li><p>UE4 Pak 文件格式  <a href="https://zhuanlan.zhihu.com/p/54531649&gt;" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54531649&gt;</a></p>
</li>
<li><p>UE4 文件系统 <a href="https://zhuanlan.zhihu.com/p/35925797&gt;" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35925797&gt;</a></p>
</li>
<li><p>大象无形 <a href="https://yuedu.163.com/book_reader/abb2cf428b244522b17aa2ec9eeea88c_4/dfd26a58c22643bf95b8a473352d5b4c_4" target="_blank" rel="noopener">https://yuedu.163.com/book_reader/abb2cf428b244522b17aa2ec9eeea88c_4/dfd26a58c22643bf95b8a473352d5b4c_4</a></p>
</li>
<li><p>UE4对象系统_序列化和uasset文件格式 <a href="https://www.jianshu.com/p/9fea500aaa4d&gt;" target="_blank" rel="noopener">https://www.jianshu.com/p/9fea500aaa4d&gt;</a></p>
</li>
<li><p>UE4 Pak 相关知识总结 <a href="https://arcecho.github.io/2017/07/02/UE4-Pak-相关知识总结/" target="_blank" rel="noopener">https://arcecho.github.io/2017/07/02/UE4-Pak-相关知识总结/</a></p>
</li>
<li><p>UE4 APK内置资源包加载流程  <a href="https://blog.csdn.net/jiangdengc/article/details/68064895&gt;" target="_blank" rel="noopener">https://blog.csdn.net/jiangdengc/article/details/68064895&gt;</a></p>
</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">BAJIAObujie</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BAJIAObujie</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.2.0"></script>
  <script src="/js/motion.js?v=7.2.0"></script>

  
  <script src="/js/schemes/muse.js?v=7.2.0"></script>


  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  




































</body>
</html>
